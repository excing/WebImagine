<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>WebImagine — 纯前端画板与多图自动排版工具</title>
  <meta name="description" content="WebImagine：单页面离线可用的画板工具，支持画笔、文本、颜色、图片导入与复制、自动排列、撤销恢复、导出下载与全屏专注模式。">
  <meta name="theme-color" content="#0f172a">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%230f172a'/%3E%3Cpath d='M12 44l10-14 8 10 12-18 10 14v8H12z' fill='%23a7f3d0'/%3E%3Ccircle cx='24' cy='20' r='6' fill='%23fbbf24'/%3E%3C/svg%3E">
  <meta property="og:type" content="website">
  <meta property="og:title" content="WebImagine — 纯前端画板与多图自动排版工具">
  <meta property="og:description" content="无需账号与安装，离线可用的画板：画笔、文字、颜色、图片导入复制、自动排列、撤销恢复、导出下载、全屏专注模式。">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="WebImagine — 纯前端画板与多图自动排版工具">
  <meta name="twitter:description" content="单文件网页应用，秒开即用。支持画笔/文字/撤销/导出/全屏。">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    "name": "WebImagine",
    "applicationCategory": "GraphicsApplication",
    "operatingSystem": "Web",
    "description": "单页面离线画板，支持画笔、文本、颜色、图片导入复制、自动排列、撤销恢复、导出下载以及全屏专注模式。",
    "softwareVersion": "1.0.0",
    "offers": {"@type": "Offer", "price": 0, "priceCurrency": "USD"},
    "url": "",
    "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAADUlEQVR4Ae3BMQEAAADCoPVPbQ0PoAAAAABNy1mKAAABNklEQVR4Xu3aMW7CQBBF0f8Uq3gq0uB3Wc7o2mQHH2b3QJAxLk5oY7c2xQyOZQm2mD7kqg9i+VYzvQ0m3b7cY0l6lFJ0y9x3oY2E/0M3kYgk8j4cZ8+o2hdgUq7v5t0jZ4uT3QZ3v0b0F8o8LxX+0g9G7s9q2N1zqk3o9n3l5n7H6gAk0w8yq+Jt4Y7eQwFh7vQH4v7i0k6g4b9z2ZQm7m8RkXx0b3F3CzGf1tC3wF1q7kGx7u7Gz9n8Fqf3g3a3v9Kf2C6z4k5p9u7n5v3eJ2bop1sR8q1D8lC5E7m4n3t4hQ6F9gO9VbJnxvC9xgJgC5o6VQ8v4rP8bH6n0U3r1J7dF9m8x6oG9b9wHk4v1s2mBqf2cQe0"
  }
  </script>
  <style>
    :root {
      color-scheme: light;
      --bg-base: #f8fafc;
      --bg-hero: #eef2ff;
      --bg-toolbar: rgba(255, 255, 255, 0.82);
      --bg-toolbar-border: rgba(148, 163, 184, 0.35);
      --primary: #2563eb;
      --primary-dark: #1d4ed8;
      --text: #0f172a;
      --text-muted: #475569;
      --surface: rgba(255, 255, 255, 0.9);
      --board-stage-height: 65vh;
      font-family: "Inter", "HarmonyOS Sans", "PingFang SC", "Microsoft YaHei", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-base);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(180deg, #fafdff 0%, var(--bg-hero) 100%);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    a {
      color: inherit;
    }

    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: clamp(16px, 3vw, 28px) clamp(20px, 6vw, 72px) 12px;
    }

    .brand {
      display: inline-flex;
      align-items: center;
      gap: 12px;
      font-size: 1.05rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .brand-icon {
      width: 36px;
      height: 36px;
      border-radius: 12px;
      background: linear-gradient(135deg, #0f172a 10%, #1e293b 90%);
      display: grid;
      place-items: center;
      color: #a7f3d0;
      font-weight: 700;
    }

    .top-links {
      display: flex;
      gap: 16px;
      align-items: center;
      font-size: 0.95rem;
      color: var(--text-muted);
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .hero {
      flex: 1;
      padding: clamp(16px, 4vw, 48px) clamp(20px, 6vw, 72px) clamp(48px, 8vw, 96px);
      display: grid;
      grid-template-columns: minmax(280px, 340px) minmax(0, 1fr);
      gap: clamp(24px, 5vw, 72px);
      align-items: stretch;
    }

    .hero-copy h1 {
      font-size: clamp(2.2rem, 3.6vw, 3.4rem);
      margin: 0 0 16px;
      letter-spacing: -0.02em;
    }

    .hero-copy p {
      margin: 0 0 20px;
      line-height: 1.6;
      color: var(--text-muted);
      font-size: 1.05rem;
    }

    .feature-list {
      list-style: none;
      margin: 0 0 20px;
      padding: 0;
      display: grid;
      gap: 10px;
    }

    .feature-list li {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      color: var(--text-muted);
    }

    .feature-list li span {
      display: inline-flex;
      font-weight: 600;
      color: var(--text);
    }

    .cta-group {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 24px;
    }

    .cta-primary,
    .cta-secondary {
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid transparent;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 150ms ease, background 150ms ease;
    }

    .cta-primary {
      background: var(--primary);
      color: #ffffff;
      box-shadow: 0 12px 24px rgba(37, 99, 235, 0.18);
    }

    .cta-primary:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
    }

    .cta-secondary {
      background: transparent;
      color: var(--primary);
      border-color: rgba(37, 99, 235, 0.4);
    }

    .cta-secondary:hover {
      background: rgba(37, 99, 235, 0.08);
      transform: translateY(-1px);
    }

    .board-shell {
      position: relative;
      display: flex;
      flex-direction: column;
      border-radius: 32px;
      background: rgba(255, 255, 255, 0.72);
      box-shadow: 0 32px 70px rgba(15, 23, 42, 0.12);
      overflow: hidden;
      backdrop-filter: saturate(1.2) blur(16px);
      border: 1px solid rgba(148, 163, 184, 0.28);
    }

    .board-shell.is-fullscreen {
      border-radius: 0;
      box-shadow: none;
    }

    .board-toolbar {
      padding: 18px clamp(16px, 3vw, 32px) 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: var(--bg-toolbar);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--bg-toolbar-border);
      position: relative;
      z-index: 2;
    }

    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .toolbar-row.tools {
      gap: 8px;
    }

    .tool-button,
    .action-button {
      height: 36px;
      padding: 0 14px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: #fff;
      color: var(--text);
      font-size: 0.9rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background 120ms ease, transform 120ms ease, box-shadow 150ms ease;
    }

    .btn-icon {
      font-size: 1.2rem;
      line-height: 1;
    }

    .btn-text {
      white-space: nowrap;
    }

    .tool-button:disabled,
    .action-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .tool-button.active {
      color: #fff;
      background: var(--primary);
      border-color: transparent;
      box-shadow: 0 8px 20px rgba(37, 99, 235, 0.25);
    }

    .tool-button:not(.active):hover,
    .action-button:not(:disabled):hover {
      background: rgba(241, 245, 249, 0.9);
      transform: translateY(-1px);
    }

    .control {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 0 12px;
      height: 36px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(255, 255, 255, 0.92);
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .control input[type="color"] {
      border: none;
      width: 32px;
      height: 20px;
      padding: 0;
      background: none;
      cursor: pointer;
    }

    .control input[type="range"] {
      width: 140px;
      height: 4px;
    }

    .control input[type="number"] {
      border: none;
      width: 55px;
      padding: 4px 6px;
      background: rgba(148, 163, 184, 0.1);
      color: var(--text);
      border-radius: 6px;
      font-size: 0.85rem;
      text-align: center;
    }

    .control input[type="number"]:focus {
      outline: 2px solid rgba(37, 99, 235, 0.3);
      background: rgba(37, 99, 235, 0.05);
    }

    .control input[type="number"]::placeholder {
      color: var(--text-muted);
      opacity: 0.6;
    }

    .arrange-control {
      display: inline-flex;
      align-items: center;
      gap: 0;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      overflow: hidden;
      background: rgba(255, 255, 255, 0.92);
    }

    .arrange-control input[type="number"] {
      border: none;
      width: 45px;
      height: 36px;
      padding: 0 6px;
      background: transparent;
      color: var(--text);
      font-size: 0.85rem;
      text-align: center;
      border-right: 1px solid rgba(148, 163, 184, 0.2);
    }

    .arrange-control input[type="number"]:last-of-type {
      border-right: none;
    }

    .arrange-control input[type="number"]:focus {
      outline: none;
      background: rgba(37, 99, 235, 0.08);
    }

    .arrange-control .action-button {
      border: none;
      border-radius: 0;
      background: transparent;
      border-left: 1px solid rgba(148, 163, 184, 0.2);
    }

    .arrange-control .action-button:hover {
      background: rgba(37, 99, 235, 0.08);
    }

    .canvas-size-control {
      display: inline-flex;
      align-items: center;
      gap: 0;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      overflow: hidden;
      background: rgba(255, 255, 255, 0.92);
      height: 36px;
    }

    .canvas-size-control input[type="number"] {
      border: none;
      height: 36px;
      padding: 0 10px;
      background: transparent;
      color: var(--text);
      font-size: 0.85rem;
      text-align: center;
      border-right: 1px solid rgba(148, 163, 184, 0.2);
      width: 70px;
    }

    .canvas-size-control input[type="number"]:last-of-type {
      width: 70px;
    }

    .canvas-size-control input[type="number"]::placeholder {
      color: var(--text-muted);
      opacity: 0.6;
    }

    .canvas-size-control input[type="number"]:focus {
      outline: none;
      background: rgba(37, 99, 235, 0.08);
    }

    .canvas-size-control .action-button {
      border: none;
      border-radius: 0;
      background: transparent;
      border-left: 1px solid rgba(148, 163, 184, 0.2);
      height: 36px;
      padding: 0 12px;
    }

    .canvas-size-control .action-button:hover {
      background: rgba(37, 99, 235, 0.08);
    }

    .history-control {
      display: inline-flex;
      align-items: center;
      gap: 0;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      overflow: hidden;
      background: rgba(255, 255, 255, 0.92);
    }

    .history-control .action-button {
      border: none;
      border-radius: 0;
      background: transparent;
      border-right: 1px solid rgba(148, 163, 184, 0.2);
      height: 36px;
      padding: 0 14px;
    }

    .history-control .action-button:last-child {
      border-right: none;
    }

    .history-control .action-button:hover {
      background: rgba(37, 99, 235, 0.08);
    }

    .history-control .action-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .brush-control {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 0 12px;
      height: 36px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(255, 255, 255, 0.92);
    }

    .brush-control span {
      text-align: center;
      font-size: 0.9rem;
    }

    .brush-control .color-input {
      display: inline-flex;
      align-items: center;
      height: 20px;
    }

    .brush-control input[type="color"] {
      border: none;
      width: 32px;
      height: 20px;
      padding: 0;
      background: none;
      cursor: pointer;
    }

    .brush-control .size-controls {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .brush-control input[type="range"] {
      width: 100px;
      height: 4px;
      cursor: pointer;
    }

    .brush-control input[type="number"] {
      border: none;
      width: 45px;
      padding: 4px 6px;
      background: rgba(148, 163, 184, 0.1);
      color: var(--text);
      border-radius: 6px;
      font-size: 0.85rem;
      text-align: center;
    }

    .brush-control input[type="number"]:focus {
      outline: 2px solid rgba(37, 99, 235, 0.3);
      background: rgba(37, 99, 235, 0.05);
    }

    .zoom-control {
      display: inline-flex;
      align-items: center;
      gap: 0;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      overflow: hidden;
      background: rgba(255, 255, 255, 0.92);
      height: 36px;
    }

    .zoom-control span {
      padding: 0 10px;
      text-align: center;
      font-size: 0.9rem;
    }

    .zoom-control .zoom-inputs {
      display: inline-flex;
      align-items: center;
      gap: 0;
      height: 36px;
      border-right: 1px solid rgba(148, 163, 184, 0.2);
    }

    .zoom-control input[type="range"] {
      width: 100px;
      height: 4px;
      cursor: pointer;
      margin: 0 8px;
      border: none;
      background: none;
    }

    .zoom-control input[type="number"] {
      border: none;
      width: 70px;
      height: 36px;
      padding: 0 8px;
      background: transparent;
      color: var(--text);
      font-size: 0.85rem;
      text-align: center;
    }

    .zoom-control input[type="number"]:focus {
      outline: none;
      background: rgba(37, 99, 235, 0.08);
    }

    .zoom-control .action-button {
      border: none;
      border-radius: 0;
      background: transparent;
      height: 36px;
      padding: 0 12px;
    }

    .zoom-control .action-button:hover {
      background: rgba(37, 99, 235, 0.08);
    }

    .zoom-control .action-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .board-stage {
      position: relative;
      flex: none;
      height: var(--board-stage-height);
      background: repeating-linear-gradient(45deg, #f8fafc 0, #f8fafc 12px, #eef2ff 12px, #eef2ff 24px);
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      overflow: auto;
      padding: 16px;
    }

    .board-stage-inner {
      position: relative;
    }

    canvas#board {
      display: block;
      background: #ffffff;
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.2);
      border-radius: 16px;
      flex-shrink: 0;
    }

    .drop-hint {
      position: absolute;
      inset: 16px;
      border-radius: 16px;
      border: 2px dashed rgba(37, 99, 235, 0.22);
      background: rgba(37, 99, 235, 0.04);
      color: var(--primary);
      font-weight: 600;
      letter-spacing: 0.03em;
      display: grid;
      place-items: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease;
      text-align: center;
      font-size: 0.95rem;
    }

    .board-stage.dragover .drop-hint {
      opacity: 1;
    }

    footer {
      padding: 28px clamp(20px, 6vw, 72px); 
      color: rgba(71, 85, 105, 0.8);
      font-size: 0.85rem;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 12px;
    }

    .text-panel {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.45);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }

    .text-panel[hidden] {
      display: none;
    }

    .text-dialog {
      background: rgba(255, 255, 255, 0.96);
      border-radius: 20px;
      padding: 28px;
      width: min(420px, 90vw);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.22);
      display: grid;
      gap: 16px;
    }

    .text-dialog h2 {
      margin: 0;
      font-size: 1.4rem;
    }

    .text-dialog textarea {
      width: 100%;
      min-height: 110px;
      padding: 12px 14px;
      font-size: 1rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      font-family: inherit;
      resize: vertical;
    }

    .text-dialog textarea:focus {
      outline: 3px solid rgba(37, 99, 235, 0.2);
      border-color: rgba(37, 99, 235, 0.6);
    }

    .dialog-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .flat-button,
    .solid-button {
      border-radius: 12px;
      border: none;
      padding: 10px 18px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
    }

    .flat-button {
      background: rgba(148, 163, 184, 0.16);
      color: var(--text);
    }

    .flat-button:hover {
      background: rgba(148, 163, 184, 0.26);
    }

    .solid-button {
      background: var(--primary);
      color: #fff;
      box-shadow: 0 12px 24px rgba(37, 99, 235, 0.22);
    }

    .solid-button:hover {
      background: var(--primary-dark);
    }

    .toast {
      position: fixed;
      z-index: 45;
      left: 50%;
      bottom: 28px;
      transform: translate(-50%, 16px);
      padding: 10px 16px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.88);
      color: #f8fafc;
      font-size: 0.9rem;
      font-weight: 500;
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease, transform 160ms ease;
    }

    .toast.show {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    .mobile-menu-toggle {
      display: none;
    }

    .mobile-dropdown-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-toolbar);
      backdrop-filter: blur(12px);
      border-top: 1px solid var(--bg-toolbar-border);
      padding: 16px;
      z-index: 10;
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.15);
    }

    .mobile-dropdown-menu.show {
      display: block;
    }

    .mobile-menu-section {
      margin-bottom: 16px;
    }

    .mobile-menu-section:last-child {
      margin-bottom: 0;
    }

    .mobile-menu-section h3 {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin: 0 0 8px 0;
      font-weight: 600;
    }

    .mobile-menu-items {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    @media (max-width: 1080px) {
      .hero {
        grid-template-columns: 1fr;
      }

      .board-shell {
        order: 2;
      }

      .hero-copy {
        order: 1;
      }
    }

    @media (max-width: 720px) {
      .top-bar {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }

      .top-links {
        width: 100%;
        justify-content: space-between;
      }

      .board-toolbar {
        position: sticky;
        top: 0;
        z-index: 20;
      }

      .toolbar-row {
        gap: 8px;
      }

      .toolbar-row:not(.tools) {
        display: none;
      }

      .mobile-menu-toggle {
        display: inline-flex;
      }

      .toolbar-row.tools .btn-text {
        display: none;
      }

      .toolbar-row.tools .tool-button,
      .toolbar-row.tools .action-button {
        padding: 0 10px;
        min-width: 36px;
        justify-content: center;
      }

      .toolbar-row.tools .btn-icon {
        font-size: 1.2rem;
      }

      .control input[type="range"] {
        width: 110px;
        height: 4px;
      }

      footer {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
  <noscript>
    <div style="padding:12px;background:#fee2e2;color:#7f1d1d;border-bottom:1px solid #fecaca;text-align:center;font-weight:600;">
      本应用需要启用 JavaScript 才能运行；它是一个仅依赖原生 Web API 与 Fabric.js 的离线画板工具。
    </div>
  </noscript>
  <header class="top-bar">
    <div class="brand" aria-label="WebImagine">
      <span class="brand-icon" aria-hidden="true">Wi</span>
      <span>WebImagine 画板</span>
    </div>
    <div class="top-links">
      <span>纯 HTML · 离线可用</span>
      <span>⌘/Ctrl + S 保存到本地</span>
    </div>
  </header>
  <main>
    <section class="hero">
      <div class="hero-copy">
        <h1>随时随地的创作画板</h1>
        <p>WebImagine 是一个零依赖、可离线使用的纯前端画板。画笔、文字、图片与排版工具整合在一个页面中，打开即可创作、整理并导出作品。</p>
        <ul class="feature-list" aria-label="特性列表">
          <li><span>✏️ 画笔 / 橡皮擦：</span>流畅手绘、可调笔刷粗细与颜色</li>
          <li><span>🔤 文字输入：</span>随时添加文字并保留可编辑属性</li>
          <li><span>🖼️ 图片导入：</span>拖拽或选择文件，支持批量自动网格排版</li>
          <li><span>↩️ 撤销恢复：</span>无限次撤销 / 恢复与图层复制</li>
          <li><span>📤 导出下载：</span>一键导出 PNG，快速分享成果</li>
          <li><span>⛶ 全屏专注：</span>进入沉浸模式，聚焦创作</li>
        </ul>
        <div class="cta-group">
          <button class="cta-primary" type="button" data-action="focus-board">立即创作</button>
          <button class="cta-secondary" type="button" data-action="enter-fullscreen">全屏专注模式</button>
        </div>
      </div>
      <div class="board-shell" id="boardShell" aria-label="交互画板">
        <div class="board-toolbar" role="toolbar" aria-label="画板工具栏">
          <div class="toolbar-row tools">
            <button class="tool-button active" type="button" data-tool="pointer"><span class="btn-icon" style="padding-bottom: 4px;">⌖</span><span class="btn-text">选择</span></button>
            <button class="tool-button" type="button" data-tool="pan"><span class="btn-icon">✋</span><span class="btn-text">拖动</span></button>
            <button class="tool-button" type="button" data-tool="brush"><span class="btn-icon">✏️</span><span class="btn-text">画笔</span></button>
            <button class="tool-button" type="button" data-action="text"><span class="btn-icon">T</span><span class="btn-text">文字</span></button>
            <button class="tool-button" type="button" data-tool="eraser"><span class="btn-icon">◻️</span><span class="btn-text">橡皮擦</span></button>
            <button class="action-button mobile-menu-toggle" type="button" data-action="toggle-menu" aria-label="更多操作"><span class="btn-icon">☰</span><span class="btn-text">更多</span></button>
            <div class="history-control" title="历史操作">
              <button class="action-button" type="button" data-action="undo" aria-label="撤销 (Ctrl+Z)">撤销</button>
              <button class="action-button" type="button" data-action="redo" aria-label="恢复 (Ctrl+Shift+Z)">恢复</button>
              <button class="action-button" type="button" data-action="reset" aria-label="清空画布">清空</button>
            </div>
          </div>
          <div class="toolbar-row">
            <div class="brush-control" title="画笔设置">
              <span class="btn-text">画笔</span>
              <div class="color-input">
                <input type="color" value="#ef4444" id="colorPicker" aria-label="画笔颜色" />
              </div>
              <div class="size-controls">
                <input type="range" min="1" max="60" value="4" id="brushSize" aria-label="画笔粗细" />
                <input type="number" min="1" max="60" value="4" id="brushSizeNumber" aria-label="画笔粗细数值" />
              </div>
            </div>
            <div class="canvas-size-control" title="画布尺寸">
              <input type="number" min="1920" value="0" id="canvasWidth" aria-label="画布宽度" placeholder="宽" />
              <input type="number" min="1080" value="0" id="canvasHeight" aria-label="画布高度" placeholder="高" />
              <button class="action-button" type="button" data-action="auto-fit" aria-label="自动调整画布大小">自动调整</button>
            </div>
            <div class="zoom-control" title="缩放和定位">
              <span>缩放</span>
              <div class="zoom-inputs">
                <input type="range" min="10" max="400" value="100" id="zoomRange" aria-label="缩放" />
                <input type="number" min="10" max="400" value="100" id="zoomNumber" aria-label="缩放数值(%)" />
              </div>
              <button class="action-button" type="button" data-action="fit-content" aria-label="定位内容" title="将画面缩放并定位到全部内容">定位内容</button>
            </div>
          </div>
          <div class="toolbar-row">
            <label class="action-button" for="imageInput" role="button" tabindex="0">导入图片
              <input type="file" id="imageInput" accept="image/*" multiple hidden>
            </label>
            <button class="action-button" type="button" data-action="duplicate">复制图层</button>
            <button class="action-button" type="button" data-action="toggle-snap" aria-label="启用/禁用吸附对齐" title="启用吸附功能后，移动对象时会自动对齐到网格或其他对象">吸附</button>
            <div class="arrange-control">
              <input type="number" min="0" max="100" value="0" id="gapX" aria-label="排列X间距" placeholder="X" title="图片水平间距" />
              <input type="number" min="0" max="100" value="0" id="gapY" aria-label="排列Y间距" placeholder="Y" title="图片垂直间距" />
              <button class="action-button" type="button" data-action="arrange">自动排列</button>
            </div>
            <button class="action-button" type="button" data-action="export">导出 PNG</button>
            <button class="action-button" type="button" data-action="fullscreen">全屏专注</button>
          </div>
          <div class="mobile-dropdown-menu" id="mobileMenu">
            <div class="mobile-menu-section">
              <h3>画布设置</h3>
              <div class="canvas-size-control" style="margin-bottom: 12px;">
                <input type="number" min="240" value="0" id="canvasWidthMobile" aria-label="画布宽度" placeholder="宽" />
                <input type="number" min="240" value="0" id="canvasHeightMobile" aria-label="画布高度" placeholder="高" />
                <button class="action-button" type="button" data-action="auto-fit-mobile">自动调整</button>
              </div>
              <div class="zoom-control" style="width: 100%;">
                <div class="zoom-inputs" style="flex: 1;">
                  <input type="range" min="10" max="400" value="100" id="zoomRangeMobile" aria-label="缩放" />
                  <input type="number" min="10" max="400" value="100" id="zoomNumberMobile" aria-label="缩放数值(%)" />
                </div>
                <button class="action-button" type="button" data-action="fit-content-mobile">定位内容</button>
              </div>
            </div>
            <div class="mobile-menu-section">
              <h3>画笔设置</h3>
              <div class="brush-control" style="width: 100%; margin-bottom: 12px;">
                <div class="color-input">
                  <input type="color" value="#ef4444" id="colorPickerMobile" aria-label="画笔颜色" />
                </div>
                <div class="size-controls" style="flex: 1;">
                  <input type="range" min="1" max="60" value="8" id="brushSizeMobile" aria-label="画笔粗细" />
                  <input type="number" min="1" max="60" value="8" id="brushSizeNumberMobile" aria-label="画笔粗细数值" />
                </div>
              </div>
            </div>
            <div class="mobile-menu-section">
              <h3>操作</h3>
              <div class="history-control" style="width: 100%; margin-bottom: 12px;">
                <button class="action-button" type="button" data-action="undo-mobile" style="flex: 1; justify-content: center;">撤销</button>
                <button class="action-button" type="button" data-action="redo-mobile" style="flex: 1; justify-content: center;">恢复</button>
                <button class="action-button" type="button" data-action="reset-mobile" style="flex: 1; justify-content: center;">清空</button>
              </div>
              <div class="mobile-menu-items">
                <button class="action-button" type="button" data-action="toggle-snap-mobile">吸附</button>
                <label class="action-button" for="imageInputMobile" role="button" tabindex="0">导入图片
                  <input type="file" id="imageInputMobile" accept="image/*" multiple hidden>
                </label>
                <button class="action-button" type="button" data-action="duplicate-mobile">复制图层</button>
              </div>
            </div>
            <div class="mobile-menu-section">
              <h3>排列与导出</h3>
              <div class="mobile-menu-items" style="margin-bottom: 8px;">
                <input type="number" min="0" max="100" value="0" id="gapXMobile" aria-label="排列X间距" placeholder="X间距" title="图片水平间距" style="width: 70px; padding: 8px; border: 1px solid rgba(148, 163, 184, 0.35); border-radius: 8px;" />
                <input type="number" min="0" max="100" value="0" id="gapYMobile" aria-label="排列Y间距" placeholder="Y间距" title="图片垂直间距" style="width: 70px; padding: 8px; border: 1px solid rgba(148, 163, 184, 0.35); border-radius: 8px;" />
                <button class="action-button" type="button" data-action="arrange-mobile">自动排列</button>
              </div>
              <div class="mobile-menu-items">
                <button class="action-button" type="button" data-action="export-mobile">导出 PNG</button>
                <button class="action-button" type="button" data-action="fullscreen-mobile">全屏专注</button>
              </div>
            </div>
          </div>
        </div>
        <div class="board-stage" id="boardStage">
          <div class="board-stage-inner">
            <canvas id="board" role="img" aria-label="绘图画布"></canvas>
            <div class="drop-hint" id="dropHint">拖拽图片到这里，自动导入并排版</div>
          </div>
        </div>
      </div>
    </section>
  </main>
  <footer>
    <span>© <span id="year"></span> WebImagine. 单文件纯前端应用。</span>
    <span>快捷键：Ctrl/Cmd + Z 撤销 · Ctrl/Cmd + Shift + Z 恢复 · Delete 删除 · Ctrl/Cmd + D 复制 · 鼠标滚轮缩放 · 中键拖动/移动端双指拖动 移动画布</span>
  </footer>

  <div class="text-panel" id="textPanel" hidden>
    <div class="text-dialog" role="dialog" aria-modal="true" aria-labelledby="textDialogTitle">
      <h2 id="textDialogTitle">添加文字</h2>
      <p style="margin:0;color:var(--text-muted);font-size:0.9rem;">输入完成后，可在画布中再次双击进行编辑。</p>
      <textarea id="textInput" placeholder="输入要添加的文字…" aria-label="文字内容"></textarea>
      <div class="dialog-actions">
        <button type="button" class="flat-button" data-action="cancel-text">取消</button>
        <button type="button" class="solid-button" data-action="confirm-text">添加到画布</button>
      </div>
    </div>
  </div>

  <div class="text-panel" id="exportPanel" hidden>
    <div class="text-dialog" role="dialog" aria-modal="true" aria-labelledby="exportDialogTitle">
      <h2 id="exportDialogTitle">选择导出尺寸</h2>
      <p style="margin:0;color:var(--text-muted);font-size:0.9rem;">选择合适的缩放比例来优化导出文件大小。</p>
      <div style="display:grid;gap:10px;margin:16px 0;">
        <button type="button" class="flat-button export-size-btn" data-multiplier="1" style="padding:12px;text-align:left;">
          <div style="font-weight:600;">标准 (1x)</div>
          <div style="font-size:0.85rem;color:var(--text-muted);margin-top:4px;">文件最小，适合网络分享</div>
        </button>
        <button type="button" class="flat-button export-size-btn" data-multiplier="1.5" style="padding:12px;text-align:left;">
          <div style="font-weight:600;">高清 (1.5x)</div>
          <div style="font-size:0.85rem;color:var(--text-muted);margin-top:4px;">平衡质量和文件大小</div>
        </button>
        <button type="button" class="flat-button export-size-btn" data-multiplier="2" style="padding:12px;text-align:left;">
          <div style="font-weight:600;">超清 (2x)</div>
          <div style="font-size:0.85rem;color:var(--text-muted);margin-top:4px;">最高质量，文件最大</div>
        </button>
      </div>
      <div class="dialog-actions">
        <button type="button" class="flat-button" data-action="cancel-export">取消</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js" integrity="sha256-SPjwkVvrUS/H/htIwO6wdd0IA8eQ79/XXNAH+cPuoso=" crossorigin="anonymous"></script>
  <script>
    (function () {
      const boardShell = document.getElementById('boardShell');
      const boardStage = document.getElementById('boardStage');
      const canvasElement = document.getElementById('board');
      const colorPicker = document.getElementById('colorPicker');
      const brushSizeInput = document.getElementById('brushSize');
      const imageInput = document.getElementById('imageInput');
      const textPanel = document.getElementById('textPanel');
      const textInput = document.getElementById('textInput');
      const exportPanel = document.getElementById('exportPanel');
      const toast = document.getElementById('toast');
      const heroFocusBtn = document.querySelector('[data-action="focus-board"]');
      const heroFullscreenBtn = document.querySelector('[data-action="enter-fullscreen"]');
      const mobileMenu = document.getElementById('mobileMenu');
      
      // Mobile controls
      const colorPickerMobile = document.getElementById('colorPickerMobile');
      const brushSizeMobile = document.getElementById('brushSizeMobile');
      const canvasWidthMobile = document.getElementById('canvasWidthMobile');
      const canvasHeightMobile = document.getElementById('canvasHeightMobile');
      const imageInputMobile = document.getElementById('imageInputMobile');
      
      // Brush size number inputs
      const brushSizeNumber = document.getElementById('brushSizeNumber');
      const brushSizeNumberMobile = document.getElementById('brushSizeNumberMobile');
      
      let pendingExportMultiplier = 1;

      const canvas = new fabric.Canvas(canvasElement, {
        backgroundColor: '#ffffff',
        selection: true,
        preserveObjectStacking: true
      });

      // Zoom controls
      const zoomRange = document.getElementById('zoomRange');
      const zoomNumber = document.getElementById('zoomNumber');
      const zoomRangeMobile = document.getElementById('zoomRangeMobile');
      const zoomNumberMobile = document.getElementById('zoomNumberMobile');
      const MIN_ZOOM = 0.1;
      const MAX_ZOOM = 4;

      const history = {
        undoStack: [],
        redoStack: [],
        isRestoring: false
      };

      let currentBrushMode = 'brush';
      let snapEnabled = false;
      const SNAP_THRESHOLD = 8;
      const GRID_SIZE = 16;

      function calculateSnap(obj) {
        if (!snapEnabled || !obj) return;

        const objBounds = {
          left: obj.left - obj.getScaledWidth() / 2,
          right: obj.left + obj.getScaledWidth() / 2,
          top: obj.top - obj.getScaledHeight() / 2,
          bottom: obj.top + obj.getScaledHeight() / 2,
          centerX: obj.left,
          centerY: obj.top
        };

        let snapX = obj.left;
        let snapY = obj.top;
        let snapDistX = SNAP_THRESHOLD;
        let snapDistY = SNAP_THRESHOLD;

        // Snap to grid
        const gridSnapX = Math.round(obj.left / GRID_SIZE) * GRID_SIZE;
        const gridSnapY = Math.round(obj.top / GRID_SIZE) * GRID_SIZE;
        const gridDistX = Math.abs(obj.left - gridSnapX);
        const gridDistY = Math.abs(obj.top - gridSnapY);

        if (gridDistX < snapDistX) {
          snapX = gridSnapX;
          snapDistX = gridDistX;
        }
        if (gridDistY < snapDistY) {
          snapY = gridSnapY;
          snapDistY = gridDistY;
        }

        // Snap to other objects
        canvas.forEachObject(function (otherObj) {
          if (otherObj === obj || otherObj.selectable === false) return;

          const otherBounds = {
            left: otherObj.left - otherObj.getScaledWidth() / 2,
            right: otherObj.left + otherObj.getScaledWidth() / 2,
            top: otherObj.top - otherObj.getScaledHeight() / 2,
            bottom: otherObj.top + otherObj.getScaledHeight() / 2,
            centerX: otherObj.left,
            centerY: otherObj.top
          };

          // Snap to left/right edges
          const snapPoints = [
            { pos: otherBounds.left, objEdge: 'left', type: 'edge' },
            { pos: otherBounds.right, objEdge: 'right', type: 'edge' },
            { pos: otherBounds.centerX, objEdge: 'centerX', type: 'center' }
          ];

          snapPoints.forEach(point => {
            const dist = Math.abs(obj.left - point.pos);
            if (dist < snapDistX) {
              snapX = point.pos;
              snapDistX = dist;
            }
          });

          // Snap to top/bottom edges
          const ySnapPoints = [
            { pos: otherBounds.top, objEdge: 'top', type: 'edge' },
            { pos: otherBounds.bottom, objEdge: 'bottom', type: 'edge' },
            { pos: otherBounds.centerY, objEdge: 'centerY', type: 'center' }
          ];

          ySnapPoints.forEach(point => {
            const dist = Math.abs(obj.top - point.pos);
            if (dist < snapDistY) {
              snapY = point.pos;
              snapDistY = dist;
            }
          });
        });

        obj.left = snapX;
        obj.top = snapY;
      }

      function resizeCanvas() {
        const canvasWidthInput = document.getElementById('canvasWidth');
        const canvasHeightInput = document.getElementById('canvasHeight');
        
        let width, height;
        
        if (canvasWidthInput.value === '' || canvasWidthInput.value === '0') {
          const rect = boardStage.getBoundingClientRect();
          width = Math.max(rect.width - 32, 240);
        } else {
          width = Math.max(parseInt(canvasWidthInput.value, 10), 240);
        }
        
        if (canvasHeightInput.value === '' || canvasHeightInput.value === '0') {
          const rect = boardStage.getBoundingClientRect();
          height = Math.max(rect.height - 32, 240);
        } else {
          height = Math.max(parseInt(canvasHeightInput.value, 10), 240);
        }
        
        canvas.setWidth(width);
        canvas.setHeight(height);
        canvas.calcOffset();
        canvas.renderAll();
      }

      function updateCanvasSizeDisplay() {
        const canvasWidthInput = document.getElementById('canvasWidth');
        const canvasHeightInput = document.getElementById('canvasHeight');
        
        if (canvasWidthInput.value === '' || canvasWidthInput.value === '0') {
          canvasWidthInput.placeholder = Math.round(canvas.getWidth()).toString();
          canvasWidthInput.value = Math.round(canvas.getWidth());
        }
        if (canvasHeightInput.value === '' || canvasHeightInput.value === '0') {
          canvasHeightInput.placeholder = Math.round(canvas.getHeight()).toString();
          canvasHeightInput.value = Math.round(canvas.getHeight());
        }
      }

      function updateBoardStageHeight() {
        const boardToolbar = document.querySelector('.board-toolbar');
        const toolbarHeight = boardToolbar.offsetHeight;
        const isFullscreen = Boolean(document.fullscreenElement);
        const minHeight = 320;
        
        if (isFullscreen) {
          // 全屏模式：使用整个视口高度减去 toolbar
          const availableHeight = window.innerHeight - toolbarHeight;
          const finalHeight = Math.max(availableHeight, minHeight);
          document.documentElement.style.setProperty('--board-stage-height', `${finalHeight}px`);
        } else {
          // 非全屏模式：使用视口高度的 65%
          const defaultHeight = window.innerHeight * 0.65;
          const finalHeight = Math.max(defaultHeight, minHeight);
          document.documentElement.style.setProperty('--board-stage-height', `${finalHeight}px`);
        }
      }

      window.addEventListener('resize', () => {
        requestAnimationFrame(resizeCanvas);
        requestAnimationFrame(updateBoardStageHeight);
      });
      document.addEventListener('fullscreenchange', updateBoardStageHeight);
      boardShell.addEventListener('fullscreenchange', updateBoardStageHeight);
      
      resizeCanvas();
      updateCanvasSizeDisplay();
      updateBoardStageHeight();

      function clampZoom(z) {
        return Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, z));
      }

      function updateZoomInputs() {
        const percent = Math.round((canvas.getZoom() || 1) * 100);
        if (zoomRange) zoomRange.value = String(percent);
        if (zoomNumber) zoomNumber.value = String(percent);
        if (zoomRangeMobile) zoomRangeMobile.value = String(percent);
        if (zoomNumberMobile) zoomNumberMobile.value = String(percent);
      }

      function zoomToPercent(percent, point) {
        const z = clampZoom((percent || 100) / 100);
        const p = point || new fabric.Point(canvas.getWidth() / 2, canvas.getHeight() / 2);
        canvas.zoomToPoint(p, z);
        canvas.requestRenderAll();
        updateZoomInputs();
      }

      function showToast(message) {
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        clearTimeout(showToast.timer);
        showToast.timer = setTimeout(() => toast.classList.remove('show'), 2200);
      }

      function saveHistory() {
        if (history.isRestoring) return;
        const state = JSON.stringify(canvas);
        if (history.undoStack.length && history.undoStack[history.undoStack.length - 1] === state) {
          return;
        }
        history.undoStack.push(state);
        if (history.undoStack.length > 80) {
          history.undoStack.shift();
        }
        history.redoStack.length = 0;
        updateHistoryButtons();
      }

      function loadHistory(state) {
        history.isRestoring = true;
        canvas.loadFromJSON(state, () => {
          canvas.renderAll();
          history.isRestoring = false;
          updateHistoryButtons();
          updateCanvasSizeDisplay();
        });
      }

      function undo() {
        if (history.undoStack.length <= 1) {
          return;
        }
        const current = history.undoStack.pop();
        history.redoStack.push(current);
        const previous = history.undoStack[history.undoStack.length - 1];
        loadHistory(previous);
      }

      function redo() {
        if (!history.redoStack.length) {
          return;
        }
        const state = history.redoStack.pop();
        history.undoStack.push(state);
        loadHistory(state);
      }

      function updateHistoryButtons() {
        const undoBtn = document.querySelector('[data-action="undo"]');
        const redoBtn = document.querySelector('[data-action="redo"]');
        if (undoBtn) {
          undoBtn.disabled = history.undoStack.length <= 1;
        }
        if (redoBtn) {
          redoBtn.disabled = history.redoStack.length === 0;
        }
      }

      function setTool(tool) {
        const buttons = document.querySelectorAll('[data-tool]');
        buttons.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.tool === tool);
        });
        if (tool === 'brush') {
          currentBrushMode = 'brush';
          canvas.isDrawingMode = true;
          canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
          canvas.freeDrawingBrush.color = colorPicker.value;
          canvas.freeDrawingBrush.width = parseInt(brushSizeInput.value, 10) || 8;
          panMode = false;
          canvas.selection = true;
          canvas.forEachObject(obj => { obj.selectable = true; obj.evented = true; });
          canvas.defaultCursor = 'default';
        } else if (tool === 'eraser') {
          currentBrushMode = 'erase';
          canvas.isDrawingMode = true;
          canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
          canvas.freeDrawingBrush.color = '#ffffff';
          canvas.freeDrawingBrush.width = parseInt(brushSizeInput.value, 10) || 18;
          panMode = false;
          canvas.selection = true;
          canvas.forEachObject(obj => { obj.selectable = true; obj.evented = true; });
          canvas.defaultCursor = 'default';
        } else if (tool === 'pan') {
          canvas.isDrawingMode = false;
          panMode = true;
          canvas.selection = false;
          canvas.discardActiveObject();
          canvas.forEachObject(obj => { obj.selectable = false; obj.evented = false; });
          canvas.defaultCursor = 'grab';
          canvas.renderAll();
        } else {
          canvas.isDrawingMode = false;
          panMode = false;
          canvas.selection = true;
          canvas.forEachObject(obj => { obj.selectable = true; obj.evented = true; });
          canvas.defaultCursor = 'default';
        }
      }

      function ensureBrushSettings() {
        if (canvas.isDrawingMode && currentBrushMode === 'brush') {
          canvas.freeDrawingBrush.color = colorPicker.value;
        }
        if (canvas.isDrawingMode) {
          canvas.freeDrawingBrush.width = parseInt(brushSizeInput.value, 10) || 8;
        }
      }

      function hexFromColor(color) {
        const ctx = document.createElement('canvas').getContext('2d');
        if (!ctx) return color;
        ctx.fillStyle = color;
        const computed = ctx.fillStyle;
        if (computed.startsWith('#')) {
          return computed;
        }
        return color;
      }

      function synchronizeColorWithSelection() {
        const activeObject = canvas.getActiveObject();
        if (!activeObject) return;
        if (activeObject.type === 'textbox') {
          colorPicker.value = hexFromColor(activeObject.fill || '#ef4444');
        } else if (activeObject.type === 'path') {
          colorPicker.value = hexFromColor(activeObject.stroke || '#ef4444');
        }
      }

      function openTextDialog() {
        textPanel.hidden = false;
        textInput.value = '';
        setTool('pointer');
        setTimeout(() => textInput.focus({ preventScroll: false }), 50);
      }

      function closeTextDialog() {
        textPanel.hidden = true;
        textInput.value = '';
      }

      function addTextToCanvas() {
        const value = textInput.value.trim();
        if (!value) {
          showToast('请输入文字内容');
          textInput.focus();
          return;
        }
        const textbox = new fabric.Textbox(value, {
          left: canvas.getWidth() / 2,
          top: canvas.getHeight() / 2,
          originX: 'center',
          originY: 'center',
          fontSize: 36,
          fill: colorPicker.value,
          fontFamily: '"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
          editable: true,
          splitByGrapheme: true,
          padding: 8
        });
        canvas.add(textbox);
        canvas.setActiveObject(textbox);
        canvas.centerObject(textbox);
        textbox.enterEditing();
        textbox.hiddenTextarea && textbox.hiddenTextarea.focus();
        canvas.renderAll();
        saveHistory();
        closeTextDialog();
        showToast('文字已添加，可双击继续编辑');
      }

      function handleFiles(fileList) {
        const files = Array.from(fileList).filter(file => file.type.startsWith('image/'));
        if (!files.length) {
          showToast('请选择图片文件');
          return;
        }
        files.forEach(file => {
          const reader = new FileReader();
          reader.onload = function (evt) {
            const dataUrl = evt.target?.result;
            if (!dataUrl) return;
            fabric.Image.fromURL(dataUrl, (img) => {
              const maxWidth = canvas.getWidth() * 0.6;
              const maxHeight = canvas.getHeight() * 0.6;
              const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
              if (isFinite(scale) && scale > 0) {
                img.scale(scale);
              }
              img.set({
                left: canvas.getWidth() / 2,
                top: canvas.getHeight() / 2,
                originX: 'center',
                originY: 'center'
              });
              canvas.add(img);
              canvas.setActiveObject(img);
              canvas.centerObject(img);
              canvas.renderAll();
              saveHistory();
              showToast('图片已导入画布');
            }, { crossOrigin: 'anonymous' });
          };
          reader.readAsDataURL(file);
        });
      }

      function autoArrangeImages() {
        const images = canvas.getObjects().filter(obj => obj.type === 'image');
        if (!images.length) {
          showToast('画布上暂无图片');
          return;
        }
        const padding = 36;
        const gapX = parseInt(document.getElementById('gapX').value, 10);
        const rows = parseInt(document.getElementById('gapY').value, 10);
        const canvasWidth = canvas.getWidth();
        const canvasHeight = canvas.getHeight();

        if (rows === 0 || rows === 1) {
          // 自动换行模式
          let currentX = padding;
          let currentY = padding;
          let rowHeight = 0;

          images.forEach((img) => {
            const imgWidth = img.getScaledWidth();
            const imgHeight = img.getScaledHeight();

            if (currentX + imgWidth + gapX > canvasWidth - padding) {
              currentX = padding;
              currentY += rowHeight + gapX;
              rowHeight = 0;
            }

            img.set({
              left: currentX + imgWidth / 2,
              top: currentY + imgHeight / 2,
              originX: 'center',
              originY: 'center'
            });
            img.setCoords();

            currentX += imgWidth + gapX;
            rowHeight = Math.max(rowHeight, imgHeight);
          });
        } else {
          // 固定行数模式
          const imagesPerRow = Math.ceil(images.length / rows);
          const rowHeights = new Array(rows).fill(0);
          const rowWidths = Array.from({ length: rows }, () => []);

          // 第一遍：计算每行的最大高度和每列的宽度
          images.forEach((img, index) => {
            const row = Math.floor(index / imagesPerRow);
            const col = index % imagesPerRow;

            rowHeights[row] = Math.max(rowHeights[row], img.getScaledHeight());
            rowWidths[row][col] = img.getScaledWidth();
          });

          // 计算每行的起始 Y 坐标
          const rowYPositions = [padding];
          for (let i = 1; i < rows; i++) {
            rowYPositions[i] = rowYPositions[i - 1] + rowHeights[i - 1] + gapX;
          }

          // 第二遍：设置每个图片的位置
          images.forEach((img, index) => {
            const row = Math.floor(index / imagesPerRow);
            const col = index % imagesPerRow;

            // 计算该列的 X 位置
            let currentX = padding;
            for (let c = 0; c < col; c++) {
              if (rowWidths[row][c] !== undefined) {
                currentX += rowWidths[row][c] + gapX;
              }
            }

            const imgWidth = img.getScaledWidth();
            const imgHeight = img.getScaledHeight();

            img.set({
              left: currentX + imgWidth / 2,
              top: rowYPositions[row] + imgHeight / 2,
              originX: 'center',
              originY: 'center'
            });
            img.setCoords();
          });
        }

        canvas.discardActiveObject();
        canvas.renderAll();
        saveHistory();
        showToast('图片已自动排列');
      }

      function getContentBounds() {
        const objects = canvas.getObjects();
        if (!objects.length) return null;
        
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        
        objects.forEach(obj => {
          const bounds = obj.getBoundingRect();
          minX = Math.min(minX, bounds.left);
          minY = Math.min(minY, bounds.top);
          maxX = Math.max(maxX, bounds.left + bounds.width);
          maxY = Math.max(maxY, bounds.top + bounds.height);
        });
        
        const padding = 8;
        return {
          left: Math.max(0, minX - padding),
          top: Math.max(0, minY - padding),
          width: Math.min(canvas.getWidth(), maxX - minX + padding * 2),
          height: Math.min(canvas.getHeight(), maxY - minY + padding * 2)
        };
      }

      function getContentBoundsRaw() {
        const objects = canvas.getObjects();
        if (!objects.length) return null;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        objects.forEach(obj => {
          const w = obj.getScaledWidth();
          const h = obj.getScaledHeight();
          const left = obj.left - w / 2;
          const top = obj.top - h / 2;
          const right = obj.left + w / 2;
          const bottom = obj.top + h / 2;
          minX = Math.min(minX, left);
          minY = Math.min(minY, top);
          maxX = Math.max(maxX, right);
          maxY = Math.max(maxY, bottom);
        });
        const padding = 16;
        return { left: minX - padding, top: minY - padding, width: (maxX - minX) + padding * 2, height: (maxY - minY) + padding * 2 };
      }

      function fitContentView() {
        const bounds = getContentBoundsRaw();
        const vw = canvas.getWidth();
        const vh = canvas.getHeight();
        if (!bounds || !isFinite(bounds.width) || !isFinite(bounds.height) || bounds.width <= 0 || bounds.height <= 0) {
          canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
          updateZoomInputs();
          showToast('视图已复位');
          return;
        }
        const margin = 24;
        const scaleX = (vw - margin * 2) / bounds.width;
        const scaleY = (vh - margin * 2) / bounds.height;
        const zoom = clampZoom(Math.min(scaleX, scaleY));
        const centerX = bounds.left + bounds.width / 2;
        const centerY = bounds.top + bounds.height / 2;
        const e = -(centerX * zoom - vw / 2);
        const f = -(centerY * zoom - vh / 2);
        canvas.setViewportTransform([zoom, 0, 0, zoom, e, f]);
        canvas.requestRenderAll();
        updateZoomInputs();
        showToast('已定位到内容');
      }

      function openExportDialog() {
        exportPanel.hidden = false;
      }

      function closeExportDialog() {
        exportPanel.hidden = true;
      }

      function performExport(multiplier) {
        const objects = canvas.getObjects();
        if (!objects.length) {
          showToast('画布为空，无可导出的内容');
          return;
        }
        
        const bounds = getContentBounds();
        const exportOptions = {
          format: 'png',
          multiplier: multiplier,
          enableRetinaScaling: true
        };
        
        if (bounds) {
          exportOptions.left = bounds.left;
          exportOptions.top = bounds.top;
          exportOptions.width = bounds.width;
          exportOptions.height = bounds.height;
        }
        
        const dataUrl = canvas.toDataURL(exportOptions);
        const link = document.createElement('a');
        link.download = `webimagine-${Date.now()}.png`;
        link.href = dataUrl;
        link.click();
        closeExportDialog();
        showToast('PNG 导出完成');
      }

      function exportCanvas() {
        openExportDialog();
      }

      function duplicateObject() {
        const active = canvas.getActiveObject();
        if (!active) {
          showToast('请选择要复制的对象');
          return;
        }
        active.clone(clone => {
          clone.set({ left: active.left + 36, top: active.top + 36 });
          canvas.discardActiveObject();
          canvas.add(clone);
          canvas.setActiveObject(clone);
          clone.setCoords();
          canvas.renderAll();
          saveHistory();
          showToast('已复制一份对象');
        });
      }

      function toggleFullscreen() {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {
          boardShell.requestFullscreen?.();
        }
      }

      function resetCanvas() {
        if (!canvas.getObjects().length) {
          showToast('画布已经是空的');
          return;
        }
        canvas.clear();
        canvas.backgroundColor = '#ffffff';
        saveHistory();
        showToast('画布已清空');
      }

      function autoFitCanvas() {
        const stageRect = boardStage.getBoundingClientRect();
        const padding = 32;
        const newWidth = Math.max(stageRect.width - padding, 240);
        const newHeight = Math.max(stageRect.height - padding, 240);
        
        canvas.setWidth(newWidth);
        canvas.setHeight(newHeight);
        canvas.calcOffset();
        canvas.renderAll();
        
        document.getElementById('canvasWidth').value = Math.round(newWidth);
        document.getElementById('canvasHeight').value = Math.round(newHeight);
        
        showToast('画布已自动调整至容器大小');
      }

      function toggleMobileMenu() {
        mobileMenu.classList.toggle('show');
      }

      function syncMobileControls() {
        if (colorPickerMobile) colorPickerMobile.value = colorPicker.value;
        if (brushSizeMobile) brushSizeMobile.value = brushSizeInput.value;
        if (brushSizeNumberMobile) brushSizeNumberMobile.value = brushSizeNumber.value;
        if (canvasWidthMobile) canvasWidthMobile.value = document.getElementById('canvasWidth').value;
        if (canvasHeightMobile) canvasHeightMobile.value = document.getElementById('canvasHeight').value;
        document.getElementById('gapXMobile').value = document.getElementById('gapX').value;
        document.getElementById('gapYMobile').value = document.getElementById('gapY').value;
        const p = Math.round((canvas.getZoom() || 1) * 100);
        if (zoomRangeMobile) zoomRangeMobile.value = String(p);
        if (zoomNumberMobile) zoomNumberMobile.value = String(p);
      }

      function syncDesktopControls() {
        if (colorPickerMobile) colorPicker.value = colorPickerMobile.value;
        if (brushSizeMobile) brushSizeInput.value = brushSizeMobile.value;
        if (brushSizeNumberMobile) brushSizeNumber.value = brushSizeNumberMobile.value;
        if (canvasWidthMobile) document.getElementById('canvasWidth').value = canvasWidthMobile.value;
        if (canvasHeightMobile) document.getElementById('canvasHeight').value = canvasHeightMobile.value;
        document.getElementById('gapX').value = document.getElementById('gapXMobile').value;
        document.getElementById('gapY').value = document.getElementById('gapYMobile').value;
        if (zoomRangeMobile) {
          const p = Math.max(10, Math.min(400, parseInt(zoomRangeMobile.value, 10) || 100));
          if (zoomRange) zoomRange.value = String(p);
          if (zoomNumber) zoomNumber.value = String(p);
          zoomToPercent(p);
        }
      }

      document.getElementById('year').textContent = new Date().getFullYear();

      document.querySelectorAll('[data-tool]').forEach(button => {
        button.addEventListener('click', () => {
          setTool(button.dataset.tool);
        });
      });

      document.querySelector('[data-action="text"]').addEventListener('click', () => {
        openTextDialog();
      });

      document.querySelector('[data-action="toggle-snap"]').addEventListener('click', (e) => {
        snapEnabled = !snapEnabled;
        e.target.classList.toggle('active', snapEnabled);
        showToast(snapEnabled ? '吸附已启用' : '吸附已禁用');
      });

      document.querySelector('[data-action="undo"]').addEventListener('click', () => undo());
      document.querySelector('[data-action="redo"]').addEventListener('click', () => redo());
      document.querySelector('[data-action="arrange"]').addEventListener('click', () => autoArrangeImages());
      document.querySelector('[data-action="export"]').addEventListener('click', () => exportCanvas());
      document.querySelector('[data-action="duplicate"]').addEventListener('click', () => duplicateObject());
      document.querySelector('[data-action="fullscreen"]').addEventListener('click', () => toggleFullscreen());
      document.querySelector('[data-action="reset"]').addEventListener('click', () => resetCanvas());
      document.querySelector('[data-action="auto-fit"]').addEventListener('click', () => autoFitCanvas());
      document.querySelector('[data-action="fit-content"]').addEventListener('click', () => fitContentView());
      
      // Mobile menu toggle
      document.querySelector('[data-action="toggle-menu"]')?.addEventListener('click', () => {
        toggleMobileMenu();
        if (mobileMenu.classList.contains('show')) {
          syncMobileControls();
        }
      });
      
      // Mobile menu event listeners
      document.querySelector('[data-action="toggle-snap-mobile"]')?.addEventListener('click', (e) => {
        snapEnabled = !snapEnabled;
        e.target.classList.toggle('active', snapEnabled);
        document.querySelector('[data-action="toggle-snap"]')?.classList.toggle('active', snapEnabled);
        showToast(snapEnabled ? '吸附已启用' : '吸附已禁用');
      });
      
      document.querySelector('[data-action="undo-mobile"]')?.addEventListener('click', () => undo());
      document.querySelector('[data-action="redo-mobile"]')?.addEventListener('click', () => redo());
      document.querySelector('[data-action="arrange-mobile"]')?.addEventListener('click', () => {
        syncDesktopControls();
        autoArrangeImages();
      });
      document.querySelector('[data-action="export-mobile"]')?.addEventListener('click', () => exportCanvas());
      document.querySelector('[data-action="duplicate-mobile"]')?.addEventListener('click', () => duplicateObject());
      document.querySelector('[data-action="fullscreen-mobile"]')?.addEventListener('click', () => toggleFullscreen());
      document.querySelector('[data-action="reset-mobile"]')?.addEventListener('click', () => resetCanvas());
      document.querySelector('[data-action="auto-fit-mobile"]')?.addEventListener('click', () => {
        syncDesktopControls();
        resizeCanvas();
      });
      document.querySelector('[data-action="fit-content-mobile"]')?.addEventListener('click', () => fitContentView());
      
      // Sync mobile controls with desktop
      colorPickerMobile?.addEventListener('input', () => {
        colorPicker.value = colorPickerMobile.value;
        ensureBrushSettings();
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          if (activeObject.type === 'textbox') {
            activeObject.set('fill', colorPicker.value);
            canvas.renderAll();
            saveHistory();
          } else if (activeObject.type === 'path') {
            activeObject.set('stroke', colorPicker.value);
            canvas.renderAll();
            saveHistory();
          }
        }
      });
      
      brushSizeMobile?.addEventListener('input', () => {
        brushSizeInput.value = brushSizeMobile.value;
        brushSizeNumber.value = brushSizeMobile.value;
        brushSizeNumberMobile.value = brushSizeMobile.value;
        ensureBrushSettings();
      });

      zoomRangeMobile?.addEventListener('input', () => {
        const p = Math.max(10, Math.min(400, parseInt(zoomRangeMobile.value, 10) || 100));
        zoomRangeMobile.value = p;
        zoomNumberMobile.value = p;
        zoomRange.value = p;
        zoomNumber.value = p;
        zoomToPercent(p);
      });

      zoomNumberMobile?.addEventListener('input', () => {
        const p = Math.max(10, Math.min(400, parseInt(zoomNumberMobile.value, 10) || 100));
        zoomNumberMobile.value = p;
        zoomRangeMobile.value = p;
        zoomRange.value = p;
        zoomNumber.value = p;
        zoomToPercent(p);
      });

      brushSizeNumberMobile?.addEventListener('input', () => {
        const value = Math.max(1, Math.min(60, parseInt(brushSizeNumberMobile.value, 10) || 8));
        brushSizeNumberMobile.value = value;
        brushSizeMobile.value = value;
        brushSizeInput.value = value;
        brushSizeNumber.value = value;
        ensureBrushSettings();
      });
      
      canvasWidthMobile?.addEventListener('input', () => {
        document.getElementById('canvasWidth').value = canvasWidthMobile.value;
      });
      
      canvasHeightMobile?.addEventListener('input', () => {
        document.getElementById('canvasHeight').value = canvasHeightMobile.value;
      });
      
      imageInputMobile?.addEventListener('change', (event) => {
        handleFiles(event.target.files);
        imageInputMobile.value = '';
        mobileMenu.classList.remove('show');
      });

      heroFocusBtn?.addEventListener('click', () => {
        boardShell.scrollIntoView({ behavior: 'smooth', block: 'center' });
      });

      heroFullscreenBtn?.addEventListener('click', () => toggleFullscreen());

      document.querySelector('[data-action="cancel-text"]').addEventListener('click', () => closeTextDialog());
      document.querySelector('[data-action="confirm-text"]').addEventListener('click', () => addTextToCanvas());

      textPanel.addEventListener('click', (event) => {
        if (event.target === textPanel) {
          closeTextDialog();
        }
      });

      document.querySelectorAll('.export-size-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const multiplier = parseFloat(btn.dataset.multiplier);
          performExport(multiplier);
        });
      });

      document.querySelector('[data-action="cancel-export"]').addEventListener('click', () => closeExportDialog());

      exportPanel.addEventListener('click', (event) => {
        if (event.target === exportPanel) {
          closeExportDialog();
        }
      });

      imageInput.addEventListener('change', (event) => {
        handleFiles(event.target.files);
        imageInput.value = '';
      });

      colorPicker.addEventListener('input', () => {
        ensureBrushSettings();
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          if (activeObject.type === 'textbox') {
            activeObject.set('fill', colorPicker.value);
            canvas.renderAll();
            saveHistory();
          } else if (activeObject.type === 'path') {
            activeObject.set('stroke', colorPicker.value);
            canvas.renderAll();
            saveHistory();
          }
        }
      });

      brushSizeInput.addEventListener('input', () => {
        brushSizeNumber.value = brushSizeInput.value;
        ensureBrushSettings();
      });

      brushSizeNumber.addEventListener('input', () => {
        const value = Math.max(1, Math.min(60, parseInt(brushSizeNumber.value, 10) || 8));
        brushSizeNumber.value = value;
        brushSizeInput.value = value;
        ensureBrushSettings();
      });

      zoomRange?.addEventListener('input', () => {
        const p = Math.max(10, Math.min(400, parseInt(zoomRange.value, 10) || 100));
        zoomRange.value = p;
        zoomNumber.value = p;
        zoomToPercent(p);
      });

      zoomNumber?.addEventListener('input', () => {
        const p = Math.max(10, Math.min(400, parseInt(zoomNumber.value, 10) || 100));
        zoomNumber.value = p;
        zoomRange.value = p;
        zoomToPercent(p);
      });

      document.getElementById('canvasWidth').addEventListener('input', () => {
        resizeCanvas();
      });

      document.getElementById('canvasHeight').addEventListener('input', () => {
        resizeCanvas();
      });

      boardStage.addEventListener('dragover', (event) => {
        event.preventDefault();
        boardStage.classList.add('dragover');
      });

      boardStage.addEventListener('dragleave', () => {
        boardStage.classList.remove('dragover');
      });

      boardStage.addEventListener('drop', (event) => {
        event.preventDefault();
        boardStage.classList.remove('dragover');
        handleFiles(event.dataTransfer.files);
      });

      document.addEventListener('keydown', (event) => {
        const isInputing = event.target && (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.isContentEditable);
        if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'z') {
          event.preventDefault();
          if (event.shiftKey) {
            redo();
          } else {
            undo();
          }
        }
        if ((event.metaKey || event.ctrlKey) && (event.key.toLowerCase() === 'y')) {
          event.preventDefault();
          redo();
        }
        if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'd') {
          event.preventDefault();
          duplicateObject();
        }
        if (!isInputing && (event.key === 'Delete' || event.key === 'Backspace')) {
          const activeObjects = canvas.getActiveObjects();
          if (activeObjects.length) {
            event.preventDefault();
            activeObjects.forEach(obj => canvas.remove(obj));
            canvas.discardActiveObject();
            canvas.renderAll();
            saveHistory();
            showToast('已删除选中对象');
          }
        }
        if (event.key === 'Escape' && !textPanel.hidden) {
          closeTextDialog();
        }
        if (event.key === 'Escape' && mobileMenu?.classList.contains('show')) {
          mobileMenu.classList.remove('show');
        }
      });



      // 拖动功能状态
      let isDragging = false;
      let dragStart = { x: 0, y: 0 };
      let panMode = false;

      canvas.on('mouse:wheel', (opt) => {
        const e = opt.e;
        e.preventDefault();
        e.stopPropagation();
        const delta = e.deltaY;
        const factor = Math.pow(0.999, delta);
        let zoom = clampZoom((canvas.getZoom() || 1) * factor);
        const p = new fabric.Point(e.offsetX, e.offsetY);
        canvas.zoomToPoint(p, zoom);
        canvas.requestRenderAll();
        updateZoomInputs();
      });

      // 画布拖动功能
      canvas.on('mouse:down', (opt) => {
        const e = opt.e;
        // 拖动模式下的左键 或 中键
        if ((panMode && e.button === 0) || e.button === 1) {
          e.preventDefault();
          isDragging = true;
          dragStart = { x: e.clientX, y: e.clientY };
          canvas.selection = false;
          canvas.defaultCursor = 'grabbing';
          canvas.renderAll();
        }
      });

      canvas.on('mouse:move', (opt) => {
        if (!isDragging) return;
        const e = opt.e;
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        
        // 使用 viewportTransform 平移画布
        const vpt = canvas.viewportTransform;
        vpt[4] += dx;
        vpt[5] += dy;
        
        dragStart = { x: e.clientX, y: e.clientY };
        canvas.requestRenderAll();
      });

      canvas.on('mouse:up', (opt) => {
        if (isDragging) {
          isDragging = false;
          canvas.selection = true;
          canvas.defaultCursor = panMode ? 'grab' : 'default';
          canvas.renderAll();
        }
      });

      // 移动端触摸拖动功能
      let touchDragging = false;
      let touchStart = { x: 0, y: 0 };
      let isTwoFingerTouch = false;

      canvasElement.addEventListener('touchstart', (e) => {
        // 双指触摸用于拖动
        if (e.touches.length === 2) {
          e.preventDefault();
          isTwoFingerTouch = true;
          touchDragging = true;
          const touch = e.touches[0];
          touchStart = { x: touch.clientX, y: touch.clientY };
          canvas.selection = false;
        } else {
          isTwoFingerTouch = false;
        }
      }, { passive: false });

      canvasElement.addEventListener('touchmove', (e) => {
        if (touchDragging && isTwoFingerTouch && e.touches.length === 2) {
          e.preventDefault();
          const touch = e.touches[0];
          const dx = touch.clientX - touchStart.x;
          const dy = touch.clientY - touchStart.y;
          
          // 使用 viewportTransform 平移画布
          const vpt = canvas.viewportTransform;
          vpt[4] += dx;
          vpt[5] += dy;
          
          touchStart = { x: touch.clientX, y: touch.clientY };
          canvas.requestRenderAll();
        }
      }, { passive: false });

      canvasElement.addEventListener('touchend', (e) => {
        if (touchDragging) {
          touchDragging = false;
          isTwoFingerTouch = false;
          canvas.selection = true;
        }
      }, { passive: false });

      canvasElement.addEventListener('touchcancel', (e) => {
        if (touchDragging) {
          touchDragging = false;
          isTwoFingerTouch = false;
          canvas.selection = true;
        }
      }, { passive: false });
      
      // Close mobile menu when clicking outside
      document.addEventListener('click', (event) => {
        if (mobileMenu?.classList.contains('show')) {
          const isMenuClick = mobileMenu.contains(event.target);
          const isToggleClick = event.target.closest('[data-action="toggle-menu"]');
          if (!isMenuClick && !isToggleClick) {
            mobileMenu.classList.remove('show');
          }
        }
      });

      canvas.on('selection:created', synchronizeColorWithSelection);
      canvas.on('selection:updated', synchronizeColorWithSelection);
      canvas.on('selection:cleared', () => ensureBrushSettings());

      canvas.on('object:moving', (e) => {
        calculateSnap(e.target);
      });

      canvas.on('path:created', () => {
        if (currentBrushMode === 'erase') {
          setTool('eraser');
        }
        saveHistory();
      });
      canvas.on('object:modified', saveHistory);
      canvas.on('object:removed', saveHistory);
      canvas.on('object:added', function (e) {
        if (panMode && e.target) {
          e.target.selectable = false;
          e.target.evented = false;
        }
        if (!history.undoStack.length) {
          saveHistory();
        }
      });

      document.addEventListener('fullscreenchange', () => {
        const fullscreenButton = document.querySelector('[data-action="fullscreen"]');
        const isFull = Boolean(document.fullscreenElement);
        boardShell.classList.toggle('is-fullscreen', isFull);
        if (fullscreenButton) {
          fullscreenButton.textContent = isFull ? '退出全屏' : '全屏专注';
        }
        requestAnimationFrame(updateBoardStageHeight);
      });

      setTool('pointer');
      saveHistory();
      updateHistoryButtons();
      updateZoomInputs();
    })();
  </script>
</body>
</html>
