<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>WebImagine â€” çº¯å‰ç«¯ç”»æ¿ä¸å¤šå›¾è‡ªåŠ¨æ’ç‰ˆå·¥å…·</title>
  <meta name="description" content="WebImagineï¼šå•é¡µé¢ç¦»çº¿å¯ç”¨çš„ç”»æ¿å·¥å…·ï¼Œæ”¯æŒç”»ç¬”ã€æ–‡æœ¬ã€é¢œè‰²ã€å›¾ç‰‡å¯¼å…¥ä¸å¤åˆ¶ã€è‡ªåŠ¨æ’åˆ—ã€æ’¤é”€æ¢å¤ã€å¯¼å‡ºä¸‹è½½ä¸å…¨å±ä¸“æ³¨æ¨¡å¼ã€‚">
  <meta name="theme-color" content="#0f172a">
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%230f172a'/%3E%3Cpath d='M12 44l10-14 8 10 12-18 10 14v8H12z' fill='%23a7f3d0'/%3E%3Ccircle cx='24' cy='20' r='6' fill='%23fbbf24'/%3E%3C/svg%3E">
  <meta property="og:type" content="website">
  <meta property="og:title" content="WebImagine â€” çº¯å‰ç«¯ç”»æ¿ä¸å¤šå›¾è‡ªåŠ¨æ’ç‰ˆå·¥å…·">
  <meta property="og:description" content="æ— éœ€è´¦å·ä¸å®‰è£…ï¼Œç¦»çº¿å¯ç”¨çš„ç”»æ¿ï¼šç”»ç¬”ã€æ–‡å­—ã€é¢œè‰²ã€å›¾ç‰‡å¯¼å…¥å¤åˆ¶ã€è‡ªåŠ¨æ’åˆ—ã€æ’¤é”€æ¢å¤ã€å¯¼å‡ºä¸‹è½½ã€å…¨å±ä¸“æ³¨æ¨¡å¼ã€‚">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="WebImagine â€” çº¯å‰ç«¯ç”»æ¿ä¸å¤šå›¾è‡ªåŠ¨æ’ç‰ˆå·¥å…·">
  <meta name="twitter:description" content="å•æ–‡ä»¶ç½‘é¡µåº”ç”¨ï¼Œç§’å¼€å³ç”¨ã€‚æ”¯æŒç”»ç¬”/æ–‡å­—/æ’¤é”€/å¯¼å‡º/å…¨å±ã€‚">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    "name": "WebImagine",
    "applicationCategory": "GraphicsApplication",
    "operatingSystem": "Web",
    "description": "å•é¡µé¢ç¦»çº¿ç”»æ¿ï¼Œæ”¯æŒç”»ç¬”ã€æ–‡æœ¬ã€é¢œè‰²ã€å›¾ç‰‡å¯¼å…¥å¤åˆ¶ã€è‡ªåŠ¨æ’åˆ—ã€æ’¤é”€æ¢å¤ã€å¯¼å‡ºä¸‹è½½ä»¥åŠå…¨å±ä¸“æ³¨æ¨¡å¼ã€‚",
    "softwareVersion": "1.0.0",
    "offers": {"@type": "Offer", "price": 0, "priceCurrency": "USD"},
    "url": "",
    "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAADUlEQVR4Ae3BMQEAAADCoPVPbQ0PoAAAAABNy1mKAAABNklEQVR4Xu3aMW7CQBBF0f8Uq3gq0uB3Wc7o2mQHH2b3QJAxLk5oY7c2xQyOZQm2mD7kqg9i+VYzvQ0m3b7cY0l6lFJ0y9x3oY2E/0M3kYgk8j4cZ8+o2hdgUq7v5t0jZ4uT3QZ3v0b0F8o8LxX+0g9G7s9q2N1zqk3o9n3l5n7H6gAk0w8yq+Jt4Y7eQwFh7vQH4v7i0k6g4b9z2ZQm7m8RkXx0b3F3CzGf1tC3wF1q7kGx7u7Gz9n8Fqf3g3a3v9Kf2C6z4k5p9u7n5v3eJ2bop1sR8q1D8lC5E7m4n3t4hQ6F9gO9VbJnxvC9xgJgC5o6VQ8v4rP8bH6n0U3r1J7dF9m8x6oG9b9wHk4v1s2mBqf2cQe0"
  }
  </script>
  <style>
    :root {
      color-scheme: light;
      --bg-base: #f8fafc;
      --bg-hero: #eef2ff;
      --bg-toolbar: rgba(255, 255, 255, 0.82);
      --bg-toolbar-border: rgba(148, 163, 184, 0.35);
      --primary: #2563eb;
      --primary-dark: #1d4ed8;
      /* ç”¨äºä¸ç¬¬ä¸€è¡Œå·¥å…·æŒ‰é’®åŒºåˆ†çš„æ¿€æ´»æ€é¢œè‰² */
      --accent: #10b981; /* emerald-500 */
      --text: #0f172a;
      --text-muted: #475569;
      --surface: rgba(255, 255, 255, 0.9);
      --board-stage-height: 65vh;
      --ruler-size: 16px;
      font-family: "Inter", "HarmonyOS Sans", "PingFang SC", "Microsoft YaHei", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-base);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(180deg, #fafdff 0%, var(--bg-hero) 100%);
      color: var(--text);
      display: flex;
      flex-direction: column;
    }

    a {
      color: inherit;
    }

    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: clamp(16px, 3vw, 28px) clamp(20px, 6vw, 72px) 12px;
    }

    .brand {
      display: inline-flex;
      align-items: center;
      gap: 12px;
      font-size: 1.05rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .brand-icon {
      width: 36px;
      height: 36px;
      border-radius: 12px;
      background: linear-gradient(135deg, #0f172a 10%, #1e293b 90%);
      display: grid;
      place-items: center;
      color: #a7f3d0;
      font-weight: 700;
    }

    .top-links {
      display: flex;
      gap: 16px;
      align-items: center;
      font-size: 0.95rem;
      color: var(--text-muted);
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .hero {
      flex: 1;
      padding: clamp(16px, 4vw, 48px) clamp(20px, 6vw, 72px) clamp(48px, 8vw, 96px);
      display: grid;
      grid-template-columns: minmax(280px, 340px) minmax(0, 1fr);
      gap: clamp(24px, 5vw, 72px);
      align-items: stretch;
    }

    .hero-copy h1 {
      font-size: clamp(2.2rem, 3.6vw, 3.4rem);
      margin: 0 0 16px;
      letter-spacing: -0.02em;
    }

    .hero-copy p {
      margin: 0 0 20px;
      line-height: 1.6;
      color: var(--text-muted);
      font-size: 1.05rem;
    }

    .feature-list {
      list-style: none;
      margin: 0 0 20px;
      padding: 0;
      display: grid;
      gap: 10px;
    }

    .feature-list li {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      color: var(--text-muted);
    }

    .feature-list li span {
      display: inline-flex;
      font-weight: 600;
      color: var(--text);
    }

    .cta-group {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 24px;
    }

    .cta-primary,
    .cta-secondary {
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid transparent;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 150ms ease, background 150ms ease;
    }

    .cta-primary {
      background: var(--primary);
      color: #ffffff;
      box-shadow: 0 12px 24px rgba(37, 99, 235, 0.18);
    }

    .cta-primary:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
    }

    .cta-secondary {
      background: transparent;
      color: var(--primary);
      border-color: rgba(37, 99, 235, 0.4);
    }

    .cta-secondary:hover {
      background: rgba(37, 99, 235, 0.08);
      transform: translateY(-1px);
    }

    .board-shell {
      position: relative;
      display: flex;
      flex-direction: column;
      border-radius: 32px;
      background: rgba(255, 255, 255, 0.72);
      box-shadow: 0 32px 70px rgba(15, 23, 42, 0.12);
      overflow: hidden;
      backdrop-filter: saturate(1.2) blur(16px);
      border: 1px solid rgba(148, 163, 184, 0.28);
    }

    .board-shell.is-fullscreen {
      border-radius: 0;
      box-shadow: none;
    }

    .board-toolbar {
      padding: 18px clamp(16px, 3vw, 32px) 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: var(--bg-toolbar);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--bg-toolbar-border);
      position: relative;
      z-index: 2;
    }

    .toolbar-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .toolbar-row.tools {
      gap: 8px;
    }

    .tool-button,
    .action-button {
      height: 36px;
      padding: 0 14px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: #fff;
      color: var(--text);
      font-size: 0.9rem;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background 120ms ease, transform 120ms ease, box-shadow 150ms ease;
    }

    .btn-icon {
      font-size: 1.2rem;
      line-height: 1;
    }

    .btn-text {
      white-space: nowrap;
    }

    .tool-button:disabled,
    .action-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .tool-button.active {
      color: #fff;
      background: var(--primary);
      border-color: transparent;
      box-shadow: 0 8px 20px rgba(37, 99, 235, 0.25);
    }

    /* è¡Œä¸ºç±»æŒ‰é’®æ¿€æ´»æ€ï¼Œä¸å·¥å…·æŒ‰é’®æ ·å¼ä¸€è‡´ä½†é¢œè‰²ä¸åŒ */
    .action-button.active {
      color: #fff;
      background: var(--accent);
      border-color: transparent;
      box-shadow: 0 8px 20px rgba(16, 185, 129, 0.25);
    }

    .tool-button:not(.active):hover,
    .action-button:not(.active):hover {
      background: rgba(241, 245, 249, 0.9);
      transform: translateY(-1px);
    }

    .action-button:disabled:hover {
      transform: translateY(0px);
    }


    .control {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 0 12px;
      height: 36px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(255, 255, 255, 0.92);
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .control input[type="color"] {
      border: none;
      width: 32px;
      height: 20px;
      padding: 0;
      background: none;
      cursor: pointer;
    }

    .control input[type="range"] {
      width: 140px;
      height: 4px;
    }

    .control input[type="number"] {
      border: none;
      width: 55px;
      padding: 4px 6px;
      background: rgba(148, 163, 184, 0.1);
      color: var(--text);
      border-radius: 6px;
      font-size: 0.85rem;
      text-align: center;
    }

    .control input[type="number"]:focus {
      outline: 2px solid rgba(37, 99, 235, 0.3);
      background: rgba(37, 99, 235, 0.05);
    }

    .control input[type="number"]::placeholder {
      color: var(--text-muted);
      opacity: 0.6;
    }

    .arrange-control {
      display: inline-flex;
      align-items: center;
      gap: 0;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      overflow: hidden;
      background: rgba(255, 255, 255, 0.92);
    }

    .arrange-control input[type="number"] {
      border: none;
      width: 45px;
      height: 36px;
      padding: 0 6px;
      background: transparent;
      color: var(--text);
      font-size: 0.85rem;
      text-align: center;
      border-right: 1px solid rgba(148, 163, 184, 0.2);
    }

    .arrange-control input[type="number"]:last-of-type {
      border-right: none;
    }

    .arrange-control input[type="number"]:focus {
      outline: none;
      background: rgba(37, 99, 235, 0.08);
    }

    .arrange-control .action-button {
      border: none;
      border-radius: 0;
      background: transparent;
      border-left: 1px solid rgba(148, 163, 184, 0.2);
    }

    .arrange-control .action-button:hover {
      background: rgba(37, 99, 235, 0.08);
    }

    .history-control {
      display: inline-flex;
      align-items: center;
      gap: 0;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      overflow: hidden;
      background: rgba(255, 255, 255, 0.92);
    }

    .history-control .action-button {
      border: none;
      border-radius: 0;
      background: transparent;
      border-right: 1px solid rgba(148, 163, 184, 0.2);
      height: 36px;
      padding: 0 14px;
    }

    .history-control .action-button:last-child {
      border-right: none;
    }

    .history-control .action-button:hover {
      background: rgba(37, 99, 235, 0.08);
    }

    .history-control .action-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .history-control-mobile {
      display: none;
    }

    .brush-control {
      display: inline-flex;
      align-items: center;
      gap: 0;
      height: 36px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(255, 255, 255, 0.92);
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .brush-control span {
      text-align: center;
      font-size: 0.85rem;
      padding: 0 12px;
      color: inherit;
    }

    .brush-control .color-input {
      margin-right: 8px;
      display: inline-flex;
      align-items: center;
      height: 20px;
    }

    .brush-control input[type="color"] {
      border: none;
      width: 32px;
      height: 20px;
      padding: 0;
      background: none;
      cursor: pointer;
    }

    .brush-control .size-controls {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .brush-control input[type="range"] {
      width: 100px;
      height: 4px;
      cursor: pointer;
    }

    .brush-control input[type="number"] {
      border: none;
      width: 48px;
      height: 36px;
      background: transparent;
      color: var(--text);
      font-size: 0.85rem;
      text-align: center;
    }

    .brush-control input[type="number"]:focus {
      outline: none;
      background: rgba(37, 99, 235, 0.08);
    }

    .zoom-control {
      display: inline-flex;
      align-items: center;
      gap: 0;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      overflow: hidden;
      background: rgba(255, 255, 255, 0.92);
      height: 36px;
    }

    .zoom-control span {
      padding: 0 12px;
      text-align: center;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .zoom-control .zoom-inputs {
      display: inline-flex;
      align-items: center;
      gap: 0;
      height: 36px;
      border-right: 1px solid rgba(148, 163, 184, 0.2);
    }

    .zoom-control input[type="range"] {
      width: 120px;
      height: 4px;
      cursor: pointer;
      border: none;
      background: none;
    }

    .zoom-control input[type="number"] {
      border: none;
      width: 48px;
      height: 36px;
      background: transparent;
      color: var(--text);
      font-size: 0.85rem;
      text-align: center;
    }

    .zoom-control input[type="number"]:focus {
      outline: none;
      background: rgba(37, 99, 235, 0.08);
    }

    .zoom-control .action-button {
      border: none;
      border-radius: 0;
      background: transparent;
      height: 36px;
      padding: 0 12px;
    }

    .zoom-control .action-button:hover {
      background: rgba(37, 99, 235, 0.08);
    }

    .zoom-control .action-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .board-stage {
      position: relative;
      flex: none;
      height: var(--board-stage-height);
      background: repeating-linear-gradient(45deg, #f8fafc 0, #f8fafc 12px, #eef2ff 12px, #eef2ff 24px);
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      overflow: hidden; /* è§†å£é©±åŠ¨ï¼šä¸ä½¿ç”¨å®¹å™¨æ»šåŠ¨ */
      padding: 16px;
    }

    .board-stage.with-rulers { padding: var(--ruler-size) 16px 16px var(--ruler-size); }

    .board-stage-inner {
      position: relative;
    }

    canvas#board {
      display: block;
      background: transparent;
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.2);
      border-radius: 6px;
      flex-shrink: 0;
    }

    .drop-hint {
      position: absolute;
      inset: 16px;
      border-radius: 16px;
      border: 2px dashed rgba(37, 99, 235, 0.22);
      background: rgba(37, 99, 235, 0.04);
      color: var(--primary);
      font-weight: 600;
      letter-spacing: 0.03em;
      display: grid;
      place-items: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease;
      text-align: center;
      font-size: 0.95rem;
    }

    .board-stage.dragover .drop-hint {
      opacity: 1;
    }

    footer {
      padding: 28px clamp(20px, 6vw, 72px); 
      color: rgba(71, 85, 105, 0.8);
      font-size: 0.85rem;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 12px;
    }

    .text-panel {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.45);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 40;
    }

    .text-panel[hidden] {
      display: none;
    }

    .text-dialog {
      background: rgba(255, 255, 255, 0.96);
      border-radius: 20px;
      padding: 28px;
      width: min(420px, 90vw);
      box-shadow: 0 24px 60px rgba(15, 23, 42, 0.22);
      display: grid;
      gap: 16px;
    }

    .text-dialog h2 {
      margin: 0;
      font-size: 1.4rem;
    }

    .text-dialog textarea {
      width: 100%;
      min-height: 110px;
      padding: 12px 14px;
      font-size: 1rem;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      font-family: inherit;
      resize: vertical;
    }

    .text-dialog textarea:focus {
      outline: 3px solid rgba(37, 99, 235, 0.2);
      border-color: rgba(37, 99, 235, 0.6);
    }

    .dialog-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .flat-button,
    .solid-button {
      border-radius: 12px;
      border: none;
      padding: 10px 18px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
    }

    .flat-button {
      background: rgba(148, 163, 184, 0.16);
      color: var(--text);
    }

    .flat-button:hover {
      background: rgba(148, 163, 184, 0.26);
    }

    .solid-button {
      background: var(--primary);
      color: #fff;
      box-shadow: 0 12px 24px rgba(37, 99, 235, 0.22);
    }

    .solid-button:hover {
      background: var(--primary-dark);
    }

    .toast {
      position: fixed;
      z-index: 45;
      left: 50%;
      bottom: 28px;
      transform: translate(-50%, 16px);
      padding: 10px 16px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.88);
      color: #f8fafc;
      font-size: 0.9rem;
      font-weight: 500;
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease, transform 160ms ease;
    }

    .toast.show {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    .mobile-menu-toggle {
      display: none;
    }

    .mobile-dropdown-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--bg-toolbar);
      backdrop-filter: blur(12px);
      border-top: 1px solid var(--bg-toolbar-border);
      padding: 16px;
      z-index: 10;
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.15);
    }

    .mobile-dropdown-menu.show {
      display: block;
    }

    .mobile-menu-section {
      margin-bottom: 16px;
    }

    .mobile-menu-section:last-child {
      margin-bottom: 0;
    }

    .mobile-menu-section h3 {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin: 0 0 8px 0;
      font-weight: 600;
    }

    .mobile-menu-items {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    @media (max-width: 1280px) {
      .hero {
        grid-template-columns: 1fr;
      }

      .board-shell {
        order: 2;
      }

      .hero-copy {
        order: 1;
      }
    }

    @media (max-width: 720px) {
      .top-bar {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }

      .top-links {
        width: 100%;
        justify-content: space-between;
      }

      .board-toolbar {
        position: sticky;
        top: 0;
        z-index: 20;
      }

      .toolbar-row {
        gap: 8px;
      }

      .toolbar-row:not(.tools) {
        display: none;
      }

      .mobile-menu-toggle {
        display: inline-flex;
      }

      .toolbar-row.tools .btn-text {
        display: none;
      }

      .toolbar-row.tools .tool-button,
      .toolbar-row.tools .action-button {
        padding: 0 10px;
        min-width: 36px;
        justify-content: center;
      }

      .toolbar-row.tools .btn-icon {
        font-size: 1.2rem;
      }

      .control input[type="range"] {
        width: 110px;
        height: 4px;
      }

      .zoom-control input[type="range"] {
        width: 140px;
      }

      .history-control-mobile {
        display: block;
      }      

      footer {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    /* Disable native scrolling/gestures over the drawing area to allow custom pan/zoom */
    .board-stage,
    .board-stage-inner,
    canvas#board {
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      overscroll-behavior: contain;
    }

    /* è§†å£é©±åŠ¨ï¼šä¸éœ€è¦åŸç”Ÿæˆ–è‡ªå®šä¹‰æ»šåŠ¨æ¡ */

    /* Rulers */
    .ruler-x, .ruler-y, .ruler-corner {
      position: absolute;
      inset: auto;
      pointer-events: none;
      z-index: 1;
    }
    .ruler-x { top: 0; left: 0; }
    .ruler-y { top: 0; left: 0; }
    .ruler-corner { top: 0; left: 0; width: var(--ruler-size); height: var(--ruler-size); background: #f1f5f9; border-right: 1px solid rgba(15,23,42,0.12); border-bottom: 1px solid rgba(15,23,42,0.12); }

  </style>
</head>
<body>
  <noscript>
    <div style="padding:12px;background:#fee2e2;color:#7f1d1d;border-bottom:1px solid #fecaca;text-align:center;font-weight:600;">
      æœ¬åº”ç”¨éœ€è¦å¯ç”¨ JavaScript æ‰èƒ½è¿è¡Œï¼›å®ƒæ˜¯ä¸€ä¸ªä»…ä¾èµ–åŸç”Ÿ Web API ä¸ Fabric.js çš„ç¦»çº¿ç”»æ¿å·¥å…·ã€‚
    </div>
  </noscript>
  <header class="top-bar">
    <div class="brand" aria-label="WebImagine">
      <span class="brand-icon" aria-hidden="true">Wi</span>
      <span>WebImagine ç”»æ¿</span>
    </div>
    <div class="top-links">
      <span>çº¯ HTML Â· ç¦»çº¿å¯ç”¨</span>
      <span>âŒ˜/Ctrl + S ä¿å­˜åˆ°æœ¬åœ°</span>
    </div>
  </header>
  <main>
    <section class="hero">
      <div class="hero-copy">
        <h1>éšæ—¶éšåœ°çš„åˆ›ä½œç”»æ¿</h1>
        <p>WebImagine æ˜¯ä¸€ä¸ªé›¶ä¾èµ–ã€å¯ç¦»çº¿ä½¿ç”¨çš„çº¯å‰ç«¯ç”»æ¿ã€‚ç”»ç¬”ã€æ–‡å­—ã€å›¾ç‰‡ä¸æ’ç‰ˆå·¥å…·æ•´åˆåœ¨ä¸€ä¸ªé¡µé¢ä¸­ï¼Œæ‰“å¼€å³å¯åˆ›ä½œã€æ•´ç†å¹¶å¯¼å‡ºä½œå“ã€‚</p>
        <ul class="feature-list" aria-label="ç‰¹æ€§åˆ—è¡¨">
          <li><span>âœï¸ ç”»ç¬” / æ©¡çš®æ“¦ï¼š</span>æµç•…æ‰‹ç»˜ã€å¯è°ƒç¬”åˆ·ç²—ç»†ä¸é¢œè‰²</li>
          <li><span>ğŸ”¤ æ–‡å­—è¾“å…¥ï¼š</span>éšæ—¶æ·»åŠ æ–‡å­—å¹¶ä¿ç•™å¯ç¼–è¾‘å±æ€§</li>
          <li><span>ğŸ–¼ï¸ å›¾ç‰‡å¯¼å…¥ï¼š</span>æ‹–æ‹½æˆ–é€‰æ‹©æ–‡ä»¶ï¼Œæ”¯æŒæ‰¹é‡è‡ªåŠ¨ç½‘æ ¼æ’ç‰ˆ</li>
          <li><span>â†©ï¸ æ’¤é”€æ¢å¤ï¼š</span>æ— é™æ¬¡æ’¤é”€ / æ¢å¤ä¸å›¾å±‚å¤åˆ¶</li>
          <li><span>ğŸ“¤ å¯¼å‡ºä¸‹è½½ï¼š</span>ä¸€é”®å¯¼å‡º PNGï¼Œå¿«é€Ÿåˆ†äº«æˆæœ</li>
          <li><span>â›¶ å…¨å±ä¸“æ³¨ï¼š</span>è¿›å…¥æ²‰æµ¸æ¨¡å¼ï¼Œèšç„¦åˆ›ä½œ</li>
        </ul>
        <div class="cta-group">
          <button class="cta-primary" type="button" data-action="focus-board">ç«‹å³åˆ›ä½œ</button>
          <button class="cta-secondary" type="button" data-action="enter-fullscreen">å…¨å±ä¸“æ³¨æ¨¡å¼</button>
        </div>
      </div>
      <div class="board-shell" id="boardShell" aria-label="äº¤äº’ç”»æ¿">
        <div class="board-toolbar" role="toolbar" aria-label="ç”»æ¿å·¥å…·æ ">
          <div class="toolbar-row tools">
            <button class="tool-button active" type="button" data-tool="pointer" title="é€‰æ‹© (V)"><span class="btn-icon" style="padding-bottom: 4px;">âŒ–</span><span class="btn-text">é€‰æ‹©</span></button>
            <button class="tool-button" type="button" data-tool="pan" title="æ‹–åŠ¨ (Space / H)"><span class="btn-icon">âœ‹</span><span class="btn-text">æ‹–åŠ¨</span></button>
            <button class="tool-button" type="button" data-tool="brush" title="ç”»ç¬” (B)"><span class="btn-icon">âœï¸</span><span class="btn-text">ç”»ç¬”</span></button>
            <button class="tool-button" type="button" data-tool="rect" title="çŸ©å½¢"><span class="btn-icon">â–­</span><span class="btn-text">çŸ©å½¢</span></button>
            <button class="tool-button" type="button" data-tool="ellipse" title="åœ†/æ¤­åœ†"><span class="btn-icon">â—¯</span><span class="btn-text">åœ†å½¢</span></button>
            <button class="tool-button" type="button" data-action="text" title="æ–‡å­— (T)"><span class="btn-icon">T</span><span class="btn-text">æ–‡å­—</span></button>
            <button class="tool-button" type="button" data-tool="eraser" title="æ©¡çš®æ“¦ (E)"><span class="btn-icon">â—»ï¸</span><span class="btn-text">æ©¡çš®æ“¦</span></button>
            <button class="action-button" type="button" data-action="fullscreen" title="å…¨å±ä¸“æ³¨ (F)"><span class="btn-icon">â›¶</span><span class="btn-text">å…¨å±ä¸“æ³¨</span></button>
            <div class="history-control-mobile" title="å†å²æ“ä½œ">
              <button class="action-button" type="button" data-action="undo" aria-label="æ’¤é”€ (Ctrl+Z)">æ’¤é”€</button>
              <button class="action-button" type="button" data-action="redo" aria-label="æ¢å¤ (Ctrl+Shift+Z)">æ¢å¤</button>
              <button class="action-button" type="button" data-action="reset" aria-label="æ¸…ç©ºç”»å¸ƒ">æ¸…ç©º</button>
            </div>
            <button class="action-button mobile-menu-toggle" type="button" data-action="toggle-menu" aria-label="æ›´å¤šæ“ä½œ"><span class="btn-icon">â˜°</span><span class="btn-text">æ›´å¤š</span></button>
          </div>
          <div class="toolbar-row">
            <div class="brush-control" title="ç”»ç¬”è®¾ç½®">
              <span class="btn-text">ç”»ç¬”</span>
              <div class="color-input">
                <input type="color" value="#ef4444" id="colorPicker" aria-label="ç”»ç¬”é¢œè‰²" />
              </div>
              <div class="size-controls">
                <input type="range" min="1" max="60" value="4" id="brushSize" aria-label="ç”»ç¬”ç²—ç»†" />
                <input type="number" min="1" max="60" value="4" id="brushSizeNumber" aria-label="ç”»ç¬”ç²—ç»†æ•°å€¼" />
              </div>
            </div>
            <div class="control" title="å½¢çŠ¶æ ·å¼" id="shapeControls">
              <label style="display:inline-flex;align-items:center;gap:6px;">
                <input type="checkbox" id="fillEnabled" aria-label="å¯ç”¨å¡«å……" checked /> å¡«å……
              </label>
              <input type="color" value="#fbbf24" id="fillColor" aria-label="å¡«å……é¢œè‰²" />
              <span class="btn-text">è™šçº¿</span>
              <input type="text" id="dashPattern" placeholder="4,2" aria-label="è™šçº¿æ ·å¼(é€—å·åˆ†éš”)" style="width:72px;padding:4px 6px;border:none;background:rgba(148,163,184,0.1);border-radius:6px;" />
            </div>
            <div class="control" title="èƒŒæ™¯">
              <span class="btn-text">èƒŒæ™¯</span>
              <select id="bgMode" aria-label="èƒŒæ™¯æ¨¡å¼" style="border:none;background:transparent;padding:4px 6px;outline:none;">
                <option value="solid">çº¯è‰²</option>
                <option value="transparent">é€æ˜</option>
              </select>
              <input type="color" value="#ffffff" id="bgColor" aria-label="èƒŒæ™¯é¢œè‰²" />
            </div>
            <div class="zoom-control" title="ç¼©æ”¾å’Œå®šä½">
              <span>ç¼©æ”¾</span>
              <div class="zoom-inputs">
                <input type="range" min="0" max="100" step="1" value="0" id="zoomRange" aria-label="ç¼©æ”¾æ»‘æ¡" />
                <input type="number" min="10" max="1000" value="100" id="zoomNumber" aria-label="ç¼©æ”¾æ•°å€¼(%)" />
              </div>
              <button class="action-button" type="button" data-action="fit-content" aria-label="å®šä½å†…å®¹" title="å°†ç”»é¢ç¼©æ”¾å¹¶å®šä½åˆ°å…¨éƒ¨å†…å®¹">å®šä½</button>
            </div>
          </div>
          <div class="toolbar-row">
            <label class="action-button" for="imageInput" role="button" tabindex="0">å¯¼å…¥å›¾ç‰‡
              <input type="file" id="imageInput" accept="image/*" multiple hidden>
            </label>
            <button class="action-button" type="button" data-action="duplicate">å¤åˆ¶å›¾å±‚</button>
            <button class="action-button" type="button" data-action="toggle-snap" aria-label="å¯ç”¨/ç¦ç”¨å¸é™„å¯¹é½" title="å¯ç”¨å¸é™„åŠŸèƒ½åï¼Œç§»åŠ¨å¯¹è±¡æ—¶ä¼šè‡ªåŠ¨å¯¹é½åˆ°ç½‘æ ¼æˆ–å…¶ä»–å¯¹è±¡">å¸é™„</button>
            <button class="action-button" type="button" data-action="toggle-rulers" aria-label="æ˜¾ç¤º/éšè—æ ‡å°º" title="æ˜¾ç¤ºæˆ–éšè—é¡¶éƒ¨/å·¦ä¾§æ ‡å°º">æ ‡å°º</button>
            <div class="arrange-control">
              <input type="number" min="0" max="100" value="0" id="gapX" aria-label="æ’åˆ—Xé—´è·" placeholder="X" title="å›¾ç‰‡æ°´å¹³é—´è·" />
              <input type="number" min="0" max="100" value="0" id="gapY" aria-label="æ’åˆ—Yé—´è·" placeholder="Y" title="å›¾ç‰‡å‚ç›´é—´è·" />
              <input type="number" min="0" max="20" value="0" id="rows" aria-label="å›ºå®šè¡Œæ•°(0æˆ–1ä¸ºè‡ªåŠ¨æ¢è¡Œ)" placeholder="è¡Œæ•°" title="å›ºå®šè¡Œæ•°ï¼ˆ0/1=è‡ªåŠ¨æ¢è¡Œï¼Œâ‰¥2=å›ºå®šè¡Œæ•°ï¼‰" />
              <button class="action-button" type="button" data-action="arrange">è‡ªåŠ¨æ’åˆ—</button>
            </div>
            <button class="action-button" type="button" data-action="export">å¯¼å‡º PNG</button>
            <div class="history-control" title="å†å²æ“ä½œ">
              <button class="action-button" type="button" data-action="undo" aria-label="æ’¤é”€ (Ctrl+Z)">æ’¤é”€</button>
              <button class="action-button" type="button" data-action="redo" aria-label="æ¢å¤ (Ctrl+Shift+Z)">æ¢å¤</button>
              <button class="action-button" type="button" data-action="reset" aria-label="æ¸…ç©ºç”»å¸ƒ">æ¸…ç©º</button>
            </div>          </div>
          <div class="mobile-dropdown-menu" id="mobileMenu">
            <div class="mobile-menu-section">
              <h3>ç”»ç¬”å’Œç”»å¸ƒè®¾ç½®</h3>
              <div class="brush-control" style="margin-bottom: 12px;">
                <span class="btn-text">ç”»ç¬”</span>
                <div class="color-input">
                  <input type="color" value="#ef4444" id="colorPickerMobile" aria-label="ç”»ç¬”é¢œè‰²" />
                </div>
                <div class="size-controls" style="flex: 1;">
                  <input type="range" min="1" max="60" value="8" id="brushSizeMobile" aria-label="ç”»ç¬”ç²—ç»†" />
                  <input type="number" min="1" max="60" value="8" id="brushSizeNumberMobile" aria-label="ç”»ç¬”ç²—ç»†æ•°å€¼" />
                </div>
              </div>
              <div class="control" title="èƒŒæ™¯" style="margin-bottom: 12px;">
                <span class="btn-text">èƒŒæ™¯</span>
                <select id="bgModeMobile" aria-label="èƒŒæ™¯æ¨¡å¼ï¼ˆç§»åŠ¨ç«¯ï¼‰" style="border:none;background:transparent;padding:4px 6px;outline:none;">
                  <option value="solid">çº¯è‰²</option>
                  <option value="transparent">é€æ˜</option>
                </select>
                <input type="color" value="#ffffff" id="bgColorMobile" aria-label="èƒŒæ™¯é¢œè‰²ï¼ˆç§»åŠ¨ç«¯ï¼‰" />
              </div>
              <div class="zoom-control">
                <span style="white-space: nowrap; padding: 0 8px;">ç¼©æ”¾</span>
                <div class="zoom-inputs" style="flex: 1;">
                  <input type="range" min="0" max="100" step="1" value="0" id="zoomRangeMobile" aria-label="ç¼©æ”¾æ»‘æ¡" />
                  <input type="number" min="10" max="1000" value="100" id="zoomNumberMobile" aria-label="ç¼©æ”¾æ•°å€¼(%)" />
                </div>
                <button class="action-button" type="button" data-action="fit-content-mobile">å®šä½</button>
              </div>

            </div>
            <div class="mobile-menu-section">
              <h3>æ“ä½œ</h3>
              <div class="mobile-menu-items">
                <label class="action-button" for="imageInputMobile" role="button" tabindex="0">å¯¼å…¥å›¾ç‰‡
                  <input type="file" id="imageInputMobile" accept="image/*" multiple hidden>
                </label>
                <button class="action-button" type="button" data-action="duplicate-mobile">å¤åˆ¶å›¾å±‚</button>
                <button class="action-button" type="button" data-action="delete-mobile">åˆ é™¤æ‰€é€‰</button>
                <button class="action-button" type="button" data-action="toggle-snap-mobile">å¸é™„</button>
                <button class="action-button" type="button" data-action="toggle-rulers-mobile">æ ‡å°º</button>
                <div class="arrange-control" style="margin-bottom: 12px;">
                  <input type="number" min="0" max="100" value="0" id="gapXMobile" aria-label="æ’åˆ—Xé—´è·" placeholder="X" title="å›¾ç‰‡æ°´å¹³é—´è·" />
                  <input type="number" min="0" max="100" value="0" id="gapYMobile" aria-label="æ’åˆ—Yé—´è·" placeholder="Y" title="å›¾ç‰‡å‚ç›´é—´è·" />
                  <input type="number" min="0" max="20" value="0" id="rowsMobile" aria-label="å›ºå®šè¡Œæ•°(0æˆ–1ä¸ºè‡ªåŠ¨æ¢è¡Œ)" placeholder="è¡Œæ•°" title="å›ºå®šè¡Œæ•°ï¼ˆ0/1=è‡ªåŠ¨æ¢è¡Œï¼Œâ‰¥2=å›ºå®šè¡Œæ•°ï¼‰" />
                  <button class="action-button" type="button" data-action="arrange-mobile">è‡ªåŠ¨æ’åˆ—</button>
                </div>
              </div>
            </div>
            <div class="mobile-menu-section">
              <h3>å¯¼å‡º</h3>
              <div class="mobile-menu-items">
                <button class="action-button" type="button" data-action="export-mobile">å¯¼å‡º PNG</button>
              </div>
            </div>
          </div>
        </div>
        <div class="board-stage" id="boardStage">
          <canvas class="ruler-x" id="rulerX" aria-hidden="true"></canvas>
          <canvas class="ruler-y" id="rulerY" aria-hidden="true"></canvas>
          <div class="ruler-corner" id="rulerCorner" aria-hidden="true"></div>
          <div class="board-stage-inner">
            <canvas id="board" role="img" aria-label="ç»˜å›¾ç”»å¸ƒ"></canvas>
            <div class="drop-hint" id="dropHint">æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œï¼Œè‡ªåŠ¨å¯¼å…¥å¹¶æ’ç‰ˆ</div>
          </div>
        </div>
      </div>
    </section>
  </main>
  <footer>
    <span>Â© <span id="year"></span> WebImagine. å•æ–‡ä»¶çº¯å‰ç«¯åº”ç”¨ã€‚</span>
    <span>å¿«æ·é”®ï¼šCtrl/Cmd + Z æ’¤é”€ Â· Ctrl/Cmd + Shift + Z æ¢å¤ Â· Delete åˆ é™¤ Â· Ctrl/Cmd + D å¤åˆ¶ Â· V é€‰æ‹© Â· Space/H æ‹–åŠ¨ Â· B ç”»ç¬” Â· T æ–‡å­— Â· E æ©¡çš®æ“¦ Â· F å…¨å± Â· é¼ æ ‡æ»šè½®ç¼©æ”¾</span>
  </footer>

  <div class="text-panel" id="textPanel" hidden>
    <div class="text-dialog" role="dialog" aria-modal="true" aria-labelledby="textDialogTitle">
      <h2 id="textDialogTitle">æ·»åŠ æ–‡å­—</h2>
      <p style="margin:0;color:var(--text-muted);font-size:0.9rem;">è¾“å…¥å®Œæˆåï¼Œå¯åœ¨ç”»å¸ƒä¸­å†æ¬¡åŒå‡»è¿›è¡Œç¼–è¾‘ã€‚</p>
      <textarea id="textInput" placeholder="è¾“å…¥è¦æ·»åŠ çš„æ–‡å­—â€¦" aria-label="æ–‡å­—å†…å®¹"></textarea>
      <div class="dialog-actions">
        <button type="button" class="flat-button" data-action="cancel-text">å–æ¶ˆ</button>
        <button type="button" class="solid-button" data-action="confirm-text">æ·»åŠ åˆ°ç”»å¸ƒ</button>
      </div>
    </div>
  </div>

  <div class="text-panel" id="exportPanel" hidden>
    <div class="text-dialog" role="dialog" aria-modal="true" aria-labelledby="exportDialogTitle">
      <h2 id="exportDialogTitle">é€‰æ‹©å¯¼å‡ºå°ºå¯¸</h2>
      <p style="margin:0;color:var(--text-muted);font-size:0.9rem;">é€‰æ‹©åˆé€‚çš„ç¼©æ”¾æ¯”ä¾‹æ¥ä¼˜åŒ–å¯¼å‡ºæ–‡ä»¶å¤§å°ã€‚</p>
      <div style="display:grid;gap:10px;margin:16px 0;">
        <button type="button" class="flat-button export-size-btn" data-multiplier="1" style="padding:12px;text-align:left;">
          <div style="font-weight:600;">æ ‡å‡† (1x)</div>
          <div style="font-size:0.85rem;color:var(--text-muted);margin-top:4px;">æ–‡ä»¶æœ€å°ï¼Œé€‚åˆç½‘ç»œåˆ†äº«</div>
        </button>
        <button type="button" class="flat-button export-size-btn" data-multiplier="1.5" style="padding:12px;text-align:left;">
          <div style="font-weight:600;">é«˜æ¸… (1.5x)</div>
          <div style="font-size:0.85rem;color:var(--text-muted);margin-top:4px;">å¹³è¡¡è´¨é‡å’Œæ–‡ä»¶å¤§å°</div>
        </button>
        <button type="button" class="flat-button export-size-btn" data-multiplier="2" style="padding:12px;text-align:left;">
          <div style="font-weight:600;">è¶…æ¸… (2x)</div>
          <div style="font-size:0.85rem;color:var(--text-muted);margin-top:4px;">æœ€é«˜è´¨é‡ï¼Œæ–‡ä»¶æœ€å¤§</div>
        </button>
      </div>
          <div style="display:flex;gap:8px;align-items:center;margin:8px 0 4px 0;">
            <input type="number" min="16" id="exportWidth" placeholder="å®½(px)" aria-label="å¯¼å‡ºå®½åº¦" style="width:120px;padding:8px 10px;border-radius:10px;border:1px solid rgba(148,163,184,0.45);" />
            <span style="opacity:0.6;">Ã—</span>
            <input type="number" min="16" id="exportHeight" placeholder="é«˜(px)" aria-label="å¯¼å‡ºé«˜åº¦" style="width:120px;padding:8px 10px;border-radius:10px;border:1px solid rgba(148,163,184,0.45);" />
            <button type="button" class="action-button" data-action="confirm-export-size" aria-label="æŒ‰å°ºå¯¸å¯¼å‡º">è‡ªåŠ¨</button>
          </div>
      <div class="dialog-actions">
        <button type="button" class="flat-button" data-action="cancel-export">å–æ¶ˆ</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js" crossorigin="anonymous"></script>
  <script>
    (function () {
      const boardShell = document.getElementById('boardShell');
      const boardStage = document.getElementById('boardStage');
      const canvasElement = document.getElementById('board');
      const colorPicker = document.getElementById('colorPicker');
      const brushSizeInput = document.getElementById('brushSize');
      const imageInput = document.getElementById('imageInput');
      const textPanel = document.getElementById('textPanel');
      const textInput = document.getElementById('textInput');
      const exportPanel = document.getElementById('exportPanel');
      const toast = document.getElementById('toast');
      const heroFocusBtn = document.querySelector('[data-action="focus-board"]');
      const heroFullscreenBtn = document.querySelector('[data-action="enter-fullscreen"]');
      const mobileMenu = document.getElementById('mobileMenu');
      // Rulers/HUD elements declared early to avoid TDZ
      const rulerX = document.getElementById('rulerX');
      const rulerY = document.getElementById('rulerY');
      const rulerCorner = document.getElementById('rulerCorner');
      let rulersEnabled = false;

      let rulerRAF = null;
      
      // Mobile controls
      const colorPickerMobile = document.getElementById('colorPickerMobile');
      const brushSizeMobile = document.getElementById('brushSizeMobile');
      const imageInputMobile = document.getElementById('imageInputMobile');
      const bgModeMobile = document.getElementById('bgModeMobile');
      const bgColorMobile = document.getElementById('bgColorMobile');
      
      // Brush size number inputs
      const brushSizeNumber = document.getElementById('brushSizeNumber');
      const brushSizeNumberMobile = document.getElementById('brushSizeNumberMobile');
      
      let pendingExportMultiplier = 1;

      const canvas = new fabric.Canvas(canvasElement, {
        backgroundColor: '#ffffff',
        selection: true,
        preserveObjectStacking: true
      });

      // Zoom controls
      const zoomRange = document.getElementById('zoomRange');
      const zoomNumber = document.getElementById('zoomNumber');
      const zoomRangeMobile = document.getElementById('zoomRangeMobile');
      const zoomNumberMobile = document.getElementById('zoomNumberMobile');
      const MIN_ZOOM = 0.1;
      const MAX_ZOOM = 10;

      const history = {
        undoStack: [],
        redoStack: [],
        isRestoring: false
      };

      let currentBrushMode = 'brush';
      let currentTool = 'pointer';
      const shapeOptions = {
        stroke: '#ef4444',
        strokeWidth: 4,
        fillEnabled: true,
        fill: '#fbbf24',
        strokeDashArray: null
      };
      const shapeState = {
        active: false,
        kind: null, // 'rect' | 'ellipse'
        start: { x: 0, y: 0 },
        preview: null
      };
      let snapEnabled = false;
      const SNAP_PX = 8; // visual tolerance in screen pixels

      function calculateSnap(obj) {
        if (!snapEnabled || !obj) return;
        const zoom = canvas.getZoom() || 1;
        const tol = SNAP_PX / zoom;

        const objHalfW = (obj.getScaledWidth && obj.getScaledWidth() / 2) || 0;
        const objHalfH = (obj.getScaledHeight && obj.getScaledHeight() / 2) || 0;

        let bestLeft = obj.left;
        let bestDx = tol;
        let bestTop = obj.top;
        let bestDy = tol;

        function considerX(selfFeature, targetX) {
          let selfX;
          if (selfFeature === 'left') selfX = obj.left - objHalfW;
          else if (selfFeature === 'right') selfX = obj.left + objHalfW;
          else selfX = obj.left; // center
          const dx = Math.abs(selfX - targetX);
          if (dx < bestDx) {
            if (selfFeature === 'left') bestLeft = targetX + objHalfW;
            else if (selfFeature === 'right') bestLeft = targetX - objHalfW;
            else bestLeft = targetX; // center
            bestDx = dx;
          }
        }

        function considerY(selfFeature, targetY) {
          let selfY;
          if (selfFeature === 'top') selfY = obj.top - objHalfH;
          else if (selfFeature === 'bottom') selfY = obj.top + objHalfH;
          else selfY = obj.top; // center
          const dy = Math.abs(selfY - targetY);
          if (dy < bestDy) {
            if (selfFeature === 'top') bestTop = targetY + objHalfH;
            else if (selfFeature === 'bottom') bestTop = targetY - objHalfH;
            else bestTop = targetY; // center
            bestDy = dy;
          }
        }

        canvas.forEachObject(function (otherObj) {
          if (otherObj === obj || otherObj.selectable === false) return;

          const otherHalfW = (otherObj.getScaledWidth && otherObj.getScaledWidth() / 2) || 0;
          const otherHalfH = (otherObj.getScaledHeight && otherObj.getScaledHeight() / 2) || 0;
          const otherBounds = {
            left: otherObj.left - otherHalfW,
            right: otherObj.left + otherHalfW,
            top: otherObj.top - otherHalfH,
            bottom: otherObj.top + otherHalfH,
            centerX: otherObj.left,
            centerY: otherObj.top
          };

          // X axis: self {left,right,center} â†” other {left,right,center}
          considerX('left', otherBounds.left);
          considerX('left', otherBounds.right);
          considerX('left', otherBounds.centerX);
          considerX('right', otherBounds.left);
          considerX('right', otherBounds.right);
          considerX('right', otherBounds.centerX);
          considerX('center', otherBounds.left);
          considerX('center', otherBounds.right);
          considerX('center', otherBounds.centerX);

          // Y axis: self {top,bottom,center} â†” other {top,bottom,center}
          considerY('top', otherBounds.top);
          considerY('top', otherBounds.bottom);
          considerY('top', otherBounds.centerY);
          considerY('bottom', otherBounds.top);
          considerY('bottom', otherBounds.bottom);
          considerY('bottom', otherBounds.centerY);
          considerY('center', otherBounds.top);
          considerY('center', otherBounds.bottom);
          considerY('center', otherBounds.centerY);
        });

        obj.left = bestLeft;
        obj.top = bestTop;
      }

      function resizeCanvas() {
        const rect = boardStage.getBoundingClientRect();
        const cs = getComputedStyle(boardStage);
        const padL = parseFloat(cs.paddingLeft) || 0;
        const padR = parseFloat(cs.paddingRight) || 0;
        const padT = parseFloat(cs.paddingTop) || 0;
        const padB = parseFloat(cs.paddingBottom) || 0;
        const width = Math.max(rect.width - (padL + padR), 240);
        const height = Math.max(rect.height - (padT + padB), 240);
        canvas.setWidth(width);
        canvas.setHeight(height);
        canvas.calcOffset();
        canvas.renderAll();
        if (typeof resizeOverlays === 'function') {
          resizeOverlays();
        }
      }

      function updateBoardStageHeight() {
        const boardToolbar = document.querySelector('.board-toolbar');
        const toolbarHeight = boardToolbar.offsetHeight;
        const isFullscreen = Boolean(document.fullscreenElement);
        const minHeight = 320;
        
        if (isFullscreen) {
          // å…¨å±æ¨¡å¼ï¼šä½¿ç”¨æ•´ä¸ªè§†å£é«˜åº¦å‡å» toolbar
          const availableHeight = window.innerHeight - toolbarHeight;
          const finalHeight = Math.max(availableHeight, minHeight);
          document.documentElement.style.setProperty('--board-stage-height', `${finalHeight}px`);
        } else {
          // éå…¨å±æ¨¡å¼ï¼šä½¿ç”¨è§†å£é«˜åº¦çš„ 65%
          const defaultHeight = window.innerHeight * 0.65;
          const finalHeight = Math.max(defaultHeight, minHeight);
          document.documentElement.style.setProperty('--board-stage-height', `${finalHeight}px`);
        }
      }

      // è‡ªå®šä¹‰å åŠ æ»šåŠ¨æ¡
      // è§†å£é©±åŠ¨æ¨¡å¼ï¼šæ— éœ€è‡ªå®šä¹‰æ»šåŠ¨æ¡

      // å…ˆæ›´æ–°å®¹å™¨é«˜åº¦ï¼Œå†ä¸‹ä¸€å¸§åŸºäºå®é™…å°ºå¯¸è°ƒæ•´ç”»å¸ƒ
      window.addEventListener('resize', () => {
        updateBoardStageHeight();
        requestAnimationFrame(() => requestAnimationFrame(resizeCanvas));
      });
      document.addEventListener('fullscreenchange', () => {
        updateBoardStageHeight();
        requestAnimationFrame(() => requestAnimationFrame(resizeCanvas));
      });
      boardShell.addEventListener('fullscreenchange', () => {
        updateBoardStageHeight();
        requestAnimationFrame(() => requestAnimationFrame(resizeCanvas));
      });
      // ç§»åŠ¨ç«¯æ–¹å‘å˜æ›´
      window.addEventListener('orientationchange', () => {
        updateBoardStageHeight();
        requestAnimationFrame(() => requestAnimationFrame(resizeCanvas));
      });

      // è§‚å¯Ÿå®¹å™¨å°ºå¯¸å˜åŒ–ï¼Œè‡ªåŠ¨è°ƒæ•´ç”»å¸ƒ
      if (window.ResizeObserver) {
        const ro = new ResizeObserver(() => {
          requestAnimationFrame(resizeCanvas);
        });
        ro.observe(boardStage);
      }
      
      updateBoardStageHeight();
      resizeCanvas();

      // Rulers and origin HUD

      function sizeCanvasForDPR(el, cssW, cssH) {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        el.width = Math.max(1, Math.round(cssW * dpr));
        el.height = Math.max(1, Math.round(cssH * dpr));
        el.style.width = cssW + 'px';
        el.style.height = cssH + 'px';
        const ctx = el.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        return ctx;
      }

      function resizeOverlays() {
        if (!boardStage) return;
        if (!rulerX || !rulerY) return;
        const cs = getComputedStyle(boardStage);
        const padL = parseFloat(cs.paddingLeft) || 0;
        const padT = parseFloat(cs.paddingTop) || 0;
        const cw = canvas.getWidth();
        const ch = canvas.getHeight();
        if (rulerX) {
          rulerX.style.left = padL + 'px';
          rulerX.style.top = '0px';
          sizeCanvasForDPR(rulerX, Math.max(1, cw), Math.max(1, padT));
        }
        if (rulerY) {
          rulerY.style.left = '0px';
          rulerY.style.top = padT + 'px';
          sizeCanvasForDPR(rulerY, Math.max(1, padL), Math.max(1, ch));
        }
        if (rulerCorner) {
          rulerCorner.style.width = padL + 'px';
          rulerCorner.style.height = padT + 'px';
          rulerCorner.style.display = rulersEnabled ? 'block' : 'none';
        }
        drawRulers();
      }

      function niceStep(raw) {
        const p10 = Math.pow(10, Math.floor(Math.log10(raw)));
        const n = raw / p10;
        let s = 1;
        if (n <= 1) s = 1; else if (n <= 2) s = 2; else if (n <= 5) s = 5; else s = 10;
        return s * p10;
      }

      function drawRulerHorizontal(ctx) {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const w = ctx.canvas.width / dpr;
        const h = ctx.canvas.height / dpr;
        ctx.clearRect(0, 0, w, h);
        if (!rulersEnabled) return;
        const vpt = canvas.viewportTransform || [1,0,0,1,0,0];
        const a = vpt[0], e = vpt[4];
        const zoom = a || 1;
        const desiredPx = 64;
        const stepWorld = Math.max(1, niceStep(desiredPx / zoom));
        const startWorld = Math.floor(((0 - e) / zoom) / stepWorld) * stepWorld;
        ctx.fillStyle = '#f1f5f9';
        ctx.fillRect(0, 0, w, h);
        ctx.strokeStyle = 'rgba(15,23,42,0.25)';
        ctx.beginPath();
        ctx.moveTo(0, h - 0.5); ctx.lineTo(w, h - 0.5); ctx.stroke();
        ctx.strokeStyle = 'rgba(15,23,42,0.35)';
        ctx.fillStyle = 'rgba(15,23,42,0.7)';
        ctx.textBaseline = 'top';
        ctx.font = '9px Inter, system-ui, -apple-system, sans-serif';
        const endWorld = ((w - e) / zoom) + stepWorld * 2;
        for (let x = startWorld; x <= endWorld; x += stepWorld) {
          const sx = x * zoom + e;
          if (sx < 0 || sx > w) continue;
          const isMajor = (Math.round(x / stepWorld) % 5) === 0;
          const tickTop = isMajor ? 0 : h * 0.4;
          ctx.beginPath();
          ctx.moveTo(Math.round(sx) + 0.5, h);
          ctx.lineTo(Math.round(sx) + 0.5, tickTop);
          ctx.stroke();
          if (isMajor && h >= 12) {
            ctx.fillText(String(Math.round(x)), sx + 2, 2);
          }
        }
      }

      function drawRulerVertical(ctx) {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const w = ctx.canvas.width / dpr;
        const h = ctx.canvas.height / dpr;
        ctx.clearRect(0, 0, w, h);
        if (!rulersEnabled) return;
        const vpt = canvas.viewportTransform || [1,0,0,1,0,0];
        const d = vpt[3], f = vpt[5];
        const zoom = d || 1;
        const desiredPx = 64;
        const stepWorld = Math.max(1, niceStep(desiredPx / zoom));
        const startWorld = Math.floor(((0 - f) / zoom) / stepWorld) * stepWorld;
        ctx.fillStyle = '#f1f5f9';
        ctx.fillRect(0, 0, w, h);
        ctx.strokeStyle = 'rgba(15,23,42,0.25)';
        ctx.beginPath();
        ctx.moveTo(w - 0.5, 0); ctx.lineTo(w - 0.5, h); ctx.stroke();
        ctx.strokeStyle = 'rgba(15,23,42,0.35)';
        ctx.fillStyle = 'rgba(15,23,42,0.7)';
        ctx.textAlign = 'right';
        ctx.font = '9px Inter, system-ui, -apple-system, sans-serif';
        const endWorld = ((h - f) / zoom) + stepWorld * 2;
        for (let y = startWorld; y <= endWorld; y += stepWorld) {
          const sy = y * zoom + f;
          if (sy < 0 || sy > h) continue;
          const isMajor = (Math.round(y / stepWorld) % 5) === 0;
          const tickLeft = isMajor ? 0 : w * 0.6;
          ctx.beginPath();
          ctx.moveTo(w, Math.round(sy) + 0.5);
          ctx.lineTo(tickLeft, Math.round(sy) + 0.5);
          ctx.stroke();
          if (isMajor && w >= 12) {
            ctx.save();
            ctx.translate(w - 2, sy + 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(String(Math.round(y)), 0, 0);
            ctx.restore();
          }
        }
      }

      function drawRulers() {
        if (rulerRAF) return;
        rulerRAF = requestAnimationFrame(() => {
          rulerRAF = null;
          if (rulerX) {
            const ctxX = rulerX.getContext('2d');
            if (ctxX) drawRulerHorizontal(ctxX);
          }
          if (rulerY) {
            const ctxY = rulerY.getContext('2d');
            if (ctxY) drawRulerVertical(ctxY);
          }
        });
      }


      function clampZoom(z) {
        return Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, z));
      }

      // å¯¹æ•°æ»‘æ¡æ˜ å°„ï¼šslider âˆˆ [0,100] â†’ percent âˆˆ [10,1000]
      function sliderToPercent(sliderValue) {
        const s = Math.max(0, Math.min(100, Number(sliderValue) || 0));
        const percent = Math.round(10 * Math.pow(100, s / 100));
        return Math.max(10, Math.min(1000, percent));
      }
      function percentToSlider(percentValue) {
        const p = Math.max(10, Math.min(1000, Number(percentValue) || 100));
        const v = 100 * Math.log(p / 10) / Math.log(100);
        return Math.max(0, Math.min(100, Math.round(v)));
      }

      function updateZoomInputs() {
        const percent = Math.round((canvas.getZoom() || 1) * 100);
        const sliderVal = percentToSlider(percent);
        if (zoomRange) zoomRange.value = String(sliderVal);
        if (zoomNumber) zoomNumber.value = String(percent);
        if (zoomRangeMobile) zoomRangeMobile.value = String(sliderVal);
        if (zoomNumberMobile) zoomNumberMobile.value = String(percent);
      }

      function zoomToPercent(percent, point) {
        const z = clampZoom((percent || 100) / 100);
        const p = point || new fabric.Point(canvas.getWidth() / 2, canvas.getHeight() / 2);
        canvas.zoomToPoint(p, z);
        canvas.requestRenderAll();
        updateZoomInputs();
      }

      function showToast(message) {
        if (!toast) return;
        toast.textContent = message;
        toast.classList.add('show');
        clearTimeout(showToast.timer);
        showToast.timer = setTimeout(() => toast.classList.remove('show'), 2200);
      }

      function saveHistory() {
        if (history.isRestoring) return;
        const state = JSON.stringify(canvas);
        if (history.undoStack.length && history.undoStack[history.undoStack.length - 1] === state) {
          return;
        }
        history.undoStack.push(state);
        if (history.undoStack.length > 80) {
          history.undoStack.shift();
        }
        history.redoStack.length = 0;
        updateHistoryButtons();
      }

      function loadHistory(state) {
        history.isRestoring = true;
        canvas.loadFromJSON(state, () => {
          canvas.renderAll();
          history.isRestoring = false;
          updateHistoryButtons();
        });
      }

      function undo() {
        if (history.undoStack.length <= 1) {
          return;
        }
        const current = history.undoStack.pop();
        history.redoStack.push(current);
        const previous = history.undoStack[history.undoStack.length - 1];
        loadHistory(previous);
      }

      function redo() {
        if (!history.redoStack.length) {
          return;
        }
        const state = history.redoStack.pop();
        history.undoStack.push(state);
        loadHistory(state);
      }

      function updateHistoryButtons() {
        const canUndo = history.undoStack.length > 1;
        const canRedo = history.redoStack.length > 0;
        // åŒæ­¥æ‰€æœ‰ä½ç½®ï¼ˆæ¡Œé¢ä¸ç§»åŠ¨ç«¯ï¼‰çš„æ’¤é”€/æ¢å¤æŒ‰é’®çŠ¶æ€
        document.querySelectorAll('[data-action="undo"], [data-action="undo-mobile"]').forEach(btn => {
          btn.disabled = !canUndo;
        });
        document.querySelectorAll('[data-action="redo"], [data-action="redo-mobile"]').forEach(btn => {
          btn.disabled = !canRedo;
        });
      }

      function setTool(tool) {
        const buttons = document.querySelectorAll('[data-tool]');
        buttons.forEach(btn => {
          btn.classList.toggle('active', btn.dataset.tool === tool);
        });
        currentTool = tool;
        if (tool === 'brush') {
          currentBrushMode = 'brush';
          canvas.isDrawingMode = true;
          canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
          canvas.freeDrawingBrush.color = colorPicker.value;
          canvas.freeDrawingBrush.width = parseInt(brushSizeInput.value, 10) || 8;
          panMode = false;
          canvas.selection = true;
          canvas.forEachObject(obj => { obj.selectable = true; obj.evented = true; });
          canvas.defaultCursor = 'default';
          canvas.skipTargetFind = false;
        } else if (tool === 'eraser') {
          currentBrushMode = 'erase';
          canvas.isDrawingMode = true;
          canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
          canvas.freeDrawingBrush.color = '#ffffff';
          canvas.freeDrawingBrush.width = parseInt(brushSizeInput.value, 10) || 18;
          panMode = false;
          canvas.selection = true;
          canvas.forEachObject(obj => { obj.selectable = true; obj.evented = true; });
          canvas.defaultCursor = 'default';
          canvas.skipTargetFind = false;
        } else if (tool === 'rect' || tool === 'ellipse') {
          canvas.isDrawingMode = false;
          panMode = false;
          canvas.selection = false;
          canvas.discardActiveObject();
          canvas.forEachObject(obj => { obj.selectable = true; obj.evented = true; });
          canvas.defaultCursor = 'crosshair';
          canvas.skipTargetFind = true;
        } else if (tool === 'pan') {
          canvas.isDrawingMode = false;
          panMode = true;
          canvas.selection = false;
          canvas.discardActiveObject();
          canvas.forEachObject(obj => { obj.selectable = false; obj.evented = false; });
          canvas.defaultCursor = 'grab';
          canvas.renderAll();
          canvas.skipTargetFind = true;
        } else {
          canvas.isDrawingMode = false;
          panMode = false;
          canvas.selection = true;
          canvas.forEachObject(obj => { obj.selectable = true; obj.evented = true; });
          canvas.defaultCursor = 'default';
          canvas.skipTargetFind = false;
        }
      }

      function ensureBrushSettings() {
        if (canvas.isDrawingMode && currentBrushMode === 'brush') {
          canvas.freeDrawingBrush.color = colorPicker.value;
        }
        if (canvas.isDrawingMode) {
          canvas.freeDrawingBrush.width = parseInt(brushSizeInput.value, 10) || 8;
        }
      }

      // èƒŒæ™¯è®¾ç½®ï¼ˆé€æ˜/çº¯è‰²ï¼‰
      const bgMode = document.getElementById('bgMode');
      const bgColor = document.getElementById('bgColor');
      if (bgMode && bgColor) {
        // åˆå§‹åŒ–ï¼šåŒæ­¥åˆ°å½“å‰ç”»å¸ƒèƒŒæ™¯
        const initialIsTransparent = !canvas.backgroundColor || canvas.backgroundColor === 'transparent';
        bgMode.value = initialIsTransparent ? 'transparent' : 'solid';
        if (!initialIsTransparent && typeof canvas.backgroundColor === 'string') {
          try { bgColor.value = hexFromColor(canvas.backgroundColor); } catch {}
        }
        bgMode.addEventListener('change', () => {
          if (bgMode.value === 'transparent') {
            canvas.setBackgroundColor(null, canvas.renderAll.bind(canvas));
          } else {
            canvas.setBackgroundColor(bgColor.value || '#ffffff', canvas.renderAll.bind(canvas));
          }
          if (typeof bgModeMobile !== 'undefined' && bgModeMobile) {
            bgModeMobile.value = bgMode.value;
          }
        });
        bgColor.addEventListener('input', () => {
          if (bgMode.value === 'solid') {
            canvas.setBackgroundColor(bgColor.value || '#ffffff', canvas.renderAll.bind(canvas));
          }
          if (typeof bgColorMobile !== 'undefined' && bgColorMobile) {
            bgColorMobile.value = bgColor.value;
          }
        });
      }

      function hexFromColor(color) {
        const ctx = document.createElement('canvas').getContext('2d');
        if (!ctx) return color;
        ctx.fillStyle = color;
        const computed = ctx.fillStyle;
        if (computed.startsWith('#')) {
          return computed;
        }
        return color;
      }

      function synchronizeColorWithSelection() {
        const activeObject = canvas.getActiveObject();
        if (!activeObject) return;
        if (activeObject.type === 'textbox') {
          colorPicker.value = hexFromColor(activeObject.fill || '#ef4444');
        } else if (activeObject.type === 'path' || activeObject.type === 'rect' || activeObject.type === 'ellipse') {
          colorPicker.value = hexFromColor(activeObject.stroke || '#ef4444');
        }
      }

      function openTextDialog() {
        textPanel.hidden = false;
        textInput.value = '';
        setTool('pointer');
        setTimeout(() => textInput.focus({ preventScroll: false }), 50);
      }

      function closeTextDialog() {
        textPanel.hidden = true;
        textInput.value = '';
      }

      function addTextToCanvas() {
        const value = textInput.value.trim();
        if (!value) {
          showToast('è¯·è¾“å…¥æ–‡å­—å†…å®¹');
          textInput.focus();
          return;
        }
        const textbox = new fabric.Textbox(value, {
          left: canvas.getWidth() / 2,
          top: canvas.getHeight() / 2,
          originX: 'center',
          originY: 'center',
          fontSize: 36,
          fill: colorPicker.value,
          fontFamily: '"Inter", "PingFang SC", "Microsoft YaHei", sans-serif',
          editable: true,
          splitByGrapheme: true,
          padding: 8
        });
        canvas.add(textbox);
        canvas.setActiveObject(textbox);
        canvas.centerObject(textbox);
        textbox.enterEditing();
        textbox.hiddenTextarea && textbox.hiddenTextarea.focus();
        canvas.renderAll();
        saveHistory();
        closeTextDialog();
        showToast('æ–‡å­—å·²æ·»åŠ ï¼Œå¯åŒå‡»ç»§ç»­ç¼–è¾‘');
      }

      function handleFiles(fileList) {
        const files = Array.from(fileList).filter(file => file.type.startsWith('image/'));
        if (!files.length) {
          showToast('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
          return;
        }
        files.forEach(file => {
          const reader = new FileReader();
          reader.onload = function (evt) {
            const dataUrl = evt.target?.result;
            if (!dataUrl) return;
            fabric.Image.fromURL(dataUrl, (img) => {
              const maxWidth = canvas.getWidth() * 0.6;
              const maxHeight = canvas.getHeight() * 0.6;
              const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
              if (isFinite(scale) && scale > 0) {
                img.scale(scale);
              }
              img.set({
                left: canvas.getWidth() / 2,
                top: canvas.getHeight() / 2,
                originX: 'center',
                originY: 'center'
              });
              canvas.add(img);
              canvas.setActiveObject(img);
              canvas.centerObject(img);
              canvas.renderAll();
              saveHistory();
              showToast('å›¾ç‰‡å·²å¯¼å…¥ç”»å¸ƒ');
            }, { crossOrigin: 'anonymous' });
          };
          reader.readAsDataURL(file);
        });
      }

      function autoArrangeImages() {
        const images = canvas.getObjects().filter(obj => obj.type === 'image');
        if (!images.length) {
          showToast('ç”»å¸ƒä¸Šæš‚æ— å›¾ç‰‡');
          return;
        }
        const padding = 36;
        const gapX = parseInt(document.getElementById('gapX').value, 10) || 0;
        const gapY = parseInt(document.getElementById('gapY').value, 10) || 0;
        const rows = parseInt(document.getElementById('rows')?.value, 10) || 0;
        const canvasWidth = canvas.getWidth();
        const canvasHeight = canvas.getHeight();

        if (rows === 0 || rows === 1) {
          // è‡ªåŠ¨æ¢è¡Œæ¨¡å¼
          let currentX = padding;
          let currentY = padding;
          let rowHeight = 0;

          images.forEach((img) => {
            const imgWidth = img.getScaledWidth();
            const imgHeight = img.getScaledHeight();

            if (currentX + imgWidth + gapX > canvasWidth - padding) {
              currentX = padding;
              currentY += rowHeight + gapY;
              rowHeight = 0;
            }

            img.set({
              left: currentX + imgWidth / 2,
              top: currentY + imgHeight / 2,
              originX: 'center',
              originY: 'center'
            });
            img.setCoords();

            currentX += imgWidth + gapX;
            rowHeight = Math.max(rowHeight, imgHeight);
          });
        } else {
          // å›ºå®šè¡Œæ•°æ¨¡å¼
          const imagesPerRow = Math.ceil(images.length / rows);
          const rowHeights = new Array(rows).fill(0);
          const rowWidths = Array.from({ length: rows }, () => []);

          // ç¬¬ä¸€éï¼šè®¡ç®—æ¯è¡Œçš„æœ€å¤§é«˜åº¦å’Œæ¯åˆ—çš„å®½åº¦
          images.forEach((img, index) => {
            const row = Math.floor(index / imagesPerRow);
            const col = index % imagesPerRow;

            rowHeights[row] = Math.max(rowHeights[row], img.getScaledHeight());
            rowWidths[row][col] = img.getScaledWidth();
          });

          // è®¡ç®—æ¯è¡Œçš„èµ·å§‹ Y åæ ‡
          const rowYPositions = [padding];
          for (let i = 1; i < rows; i++) {
            rowYPositions[i] = rowYPositions[i - 1] + rowHeights[i - 1] + gapY;
          }

          // ç¬¬äºŒéï¼šè®¾ç½®æ¯ä¸ªå›¾ç‰‡çš„ä½ç½®
          images.forEach((img, index) => {
            const row = Math.floor(index / imagesPerRow);
            const col = index % imagesPerRow;

            // è®¡ç®—è¯¥åˆ—çš„ X ä½ç½®
            let currentX = padding;
            for (let c = 0; c < col; c++) {
              if (rowWidths[row][c] !== undefined) {
                currentX += rowWidths[row][c] + gapX;
              }
            }

            const imgWidth = img.getScaledWidth();
            const imgHeight = img.getScaledHeight();

            img.set({
              left: currentX + imgWidth / 2,
              top: rowYPositions[row] + imgHeight / 2,
              originX: 'center',
              originY: 'center'
            });
            img.setCoords();
          });
        }

        canvas.discardActiveObject();
        canvas.renderAll();
        saveHistory();
        showToast('å›¾ç‰‡å·²è‡ªåŠ¨æ’åˆ—');
      }

      function computeContentBounds(options) {
        const onlyVisible = !(options && options.onlyVisible === false);
        const includeStroke = !(options && options.includeStroke === false);
        const objects = canvas.getObjects().filter(o => (onlyVisible ? o.visible !== false : true));
        if (!objects.length) return null;
        const prevVpt = (canvas.viewportTransform || [1, 0, 0, 1, 0, 0]).slice();
        canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        objects.forEach(obj => {
          obj.setCoords();
          let r;
          try {
            r = obj.getBoundingRect({ absolute: true, includeStroke });
          } catch (e1) {
            try {
              r = obj.getBoundingRect(true, true);
            } catch (e2) {
              r = obj.getBoundingRect();
            }
          }
          minX = Math.min(minX, r.left);
          minY = Math.min(minY, r.top);
          maxX = Math.max(maxX, r.left + r.width);
          maxY = Math.max(maxY, r.top + r.height);
        });
        canvas.setViewportTransform(prevVpt);
        const padding = 16;
        return { left: minX - padding, top: minY - padding, width: (maxX - minX) + padding * 2, height: (maxY - minY) + padding * 2 };
      }

      function getContentBounds() {
        const b = computeContentBounds({ includeStroke: true, onlyVisible: true });
        if (!b) return null;
        const cw = canvas.getWidth();
        const ch = canvas.getHeight();
        const left = Math.max(0, b.left);
        const top = Math.max(0, b.top);
        const right = Math.min(cw, b.left + b.width);
        const bottom = Math.min(ch, b.top + b.height);
        return { left, top, width: Math.max(0, right - left), height: Math.max(0, bottom - top) };
      }

      function getContentBoundsRaw() {
        return computeContentBounds({ includeStroke: true, onlyVisible: true });
      }

      function fitContentView() {
        const bounds = getContentBoundsRaw();
        const vw = canvas.getWidth();
        const vh = canvas.getHeight();
        if (!bounds || !isFinite(bounds.width) || !isFinite(bounds.height) || bounds.width <= 0 || bounds.height <= 0) {
          canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
          updateZoomInputs();
          showToast('è§†å›¾å·²å¤ä½');
          return;
        }
        const margin = 24;
        const scaleX = (vw - margin * 2) / bounds.width;
        const scaleY = (vh - margin * 2) / bounds.height;
        const zoom = clampZoom(Math.min(scaleX, scaleY));
        const centerX = bounds.left + bounds.width / 2;
        const centerY = bounds.top + bounds.height / 2;
        const e = -(centerX * zoom - vw / 2);
        const f = -(centerY * zoom - vh / 2);
        canvas.setViewportTransform([zoom, 0, 0, zoom, e, f]);
        canvas.requestRenderAll();
        updateZoomInputs();
        showToast('å·²å®šä½åˆ°å†…å®¹');
      }

      function openExportDialog() {
        exportPanel.hidden = false;
      }

      function closeExportDialog() {
        exportPanel.hidden = true;
      }

      function performExport(multiplier) {
        const objects = canvas.getObjects();
        if (!objects.length) {
          showToast('ç”»å¸ƒä¸ºç©ºï¼Œæ— å¯å¯¼å‡ºçš„å†…å®¹');
          return;
        }
        
        const bounds = getContentBounds();
        const exportOptions = {
          format: 'png',
          multiplier: multiplier,
          enableRetinaScaling: true
        };
        
        if (bounds) {
          exportOptions.left = bounds.left;
          exportOptions.top = bounds.top;
          exportOptions.width = bounds.width;
          exportOptions.height = bounds.height;
        }
        
        const needTransparent = bgMode && bgMode.value === 'transparent';
        const prevBg = canvas.backgroundColor;
        const doExport = () => {
          const dataUrl = canvas.toDataURL(exportOptions);
          const link = document.createElement('a');
          link.download = `webimagine-${Date.now()}.png`;
          link.href = dataUrl;
          link.click();
          if (needTransparent) {
            canvas.setBackgroundColor(prevBg || null, canvas.renderAll.bind(canvas));
          }
          closeExportDialog();
          showToast('PNG å¯¼å‡ºå®Œæˆ');
        };
        if (needTransparent) {
          canvas.setBackgroundColor(null, () => {
            canvas.renderAll();
            doExport();
          });
        } else {
          doExport();
        }
      }

      function performExportWithSize(targetW, targetH) {
        const objects = canvas.getObjects();
        if (!objects.length) { showToast('ç”»å¸ƒä¸ºç©ºï¼Œæ— å¯å¯¼å‡ºçš„å†…å®¹'); return; }
        const b = getContentBoundsRaw();
        if (!b || b.width <= 0 || b.height <= 0) { showToast('æ— å¯å¯¼å‡ºçš„å†…å®¹'); return; }
        const TW = Math.max(16, Number(targetW) || 0);
        const TH = Math.max(16, Number(targetH) || 0);
        if (!TW || !TH) { showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„å¯¼å‡ºå°ºå¯¸'); return; }
        const cx = b.left + b.width / 2;
        const cy = b.top + b.height / 2;
        const aspectTarget = TW / TH;
        const aspectContent = b.width / b.height;
        let cropW, cropH;
        if (aspectTarget >= aspectContent) {
          cropH = b.height;
          cropW = b.height * aspectTarget;
        } else {
          cropW = b.width;
          cropH = b.width / aspectTarget;
        }
        const left = cx - cropW / 2;
        const top = cy - cropH / 2;
        const multiplier = TW / cropW; // ä¿è¯è¾“å‡ºç²¾ç¡®ä¸º targetWÃ—targetH
        const options = {
          format: 'png',
          left, top, width: cropW, height: cropH,
          multiplier,
          enableRetinaScaling: true
        };
        const needTransparent = bgMode && bgMode.value === 'transparent';
        const prevBg = canvas.backgroundColor;
        const doExportSized = () => {
          const dataUrl = canvas.toDataURL(options);
          const link = document.createElement('a');
          link.download = `webimagine-${TW}x${TH}-${Date.now()}.png`;
          link.href = dataUrl;
          link.click();
          if (needTransparent) {
            canvas.setBackgroundColor(prevBg || null, canvas.renderAll.bind(canvas));
          }
          closeExportDialog();
          showToast('PNG å¯¼å‡ºå®Œæˆ');
        };
        if (needTransparent) {
          canvas.setBackgroundColor(null, () => {
            canvas.renderAll();
            doExportSized();
          });
        } else {
          doExportSized();
        }
      }

      function exportCanvas() { openExportDialog(); }

      function duplicateObject() {
        const active = canvas.getActiveObject();
        if (!active) {
          showToast('è¯·é€‰æ‹©è¦å¤åˆ¶çš„å¯¹è±¡');
          return;
        }
        active.clone(clone => {
          clone.set({ left: active.left + 36, top: active.top + 36 });
          canvas.discardActiveObject();
          canvas.add(clone);
          canvas.setActiveObject(clone);
          clone.setCoords();
          canvas.renderAll();
          saveHistory();
          showToast('å·²å¤åˆ¶ä¸€ä»½å¯¹è±¡');
        });
      }

      function deleteActiveObjects() {
        const activeObjects = canvas.getActiveObjects();
        if (!activeObjects.length) {
          showToast('è¯·é€‰æ‹©è¦åˆ é™¤çš„å¯¹è±¡');
          return;
        }
        activeObjects.forEach(obj => canvas.remove(obj));
        canvas.discardActiveObject();
        canvas.renderAll();
        saveHistory();
        showToast('å·²åˆ é™¤é€‰ä¸­å¯¹è±¡');
        mobileMenu?.classList.remove('show');
      }

      function toggleFullscreen() {
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else {
          boardShell.requestFullscreen?.();
        }
      }

      function resetCanvas() {
        if (!canvas.getObjects().length) {
          showToast('ç”»å¸ƒå·²ç»æ˜¯ç©ºçš„');
          return;
        }
        canvas.clear();
        const isTransparent = bgMode && bgMode.value === 'transparent';
        canvas.setBackgroundColor(
          isTransparent ? null : (bgColor?.value || '#ffffff'),
          canvas.renderAll.bind(canvas)
        );
        saveHistory();
        showToast('ç”»å¸ƒå·²æ¸…ç©º');
      }

      function autoFitCanvas() {
        resizeCanvas();
        showToast('è§†å£å·²åŒ¹é…å®¹å™¨');
      }

      function toggleMobileMenu() {
        mobileMenu.classList.toggle('show');
      }

      function syncMobileControls() {
        if (colorPickerMobile) colorPickerMobile.value = colorPicker.value;
        if (brushSizeMobile) brushSizeMobile.value = brushSizeInput.value;
        if (brushSizeNumberMobile) brushSizeNumberMobile.value = brushSizeNumber.value;
        if (bgModeMobile && bgMode) bgModeMobile.value = bgMode.value;
        if (bgColorMobile && bgColor) bgColorMobile.value = bgColor.value;
        document.getElementById('gapXMobile').value = document.getElementById('gapX').value;
        document.getElementById('gapYMobile').value = document.getElementById('gapY').value;
        const rowsEl = document.getElementById('rows');
        const rowsMobileEl = document.getElementById('rowsMobile');
        if (rowsEl && rowsMobileEl) rowsMobileEl.value = rowsEl.value;
        const p = Math.round((canvas.getZoom() || 1) * 100);
        const s = percentToSlider(p);
        if (zoomRangeMobile) zoomRangeMobile.value = String(s);
        if (zoomNumberMobile) zoomNumberMobile.value = String(p);
      }

      function syncDesktopControls() {
        if (colorPickerMobile) colorPicker.value = colorPickerMobile.value;
        if (brushSizeMobile) brushSizeInput.value = brushSizeMobile.value;
        if (brushSizeNumberMobile) brushSizeNumber.value = brushSizeNumberMobile.value;
        if (bgModeMobile && bgMode) bgMode.value = bgModeMobile.value;
        if (bgColorMobile && bgColor) bgColor.value = bgColorMobile.value;
        document.getElementById('gapX').value = document.getElementById('gapXMobile').value;
        document.getElementById('gapY').value = document.getElementById('gapYMobile').value;
        const rowsEl = document.getElementById('rows');
        const rowsMobileEl = document.getElementById('rowsMobile');
        if (rowsEl && rowsMobileEl) rowsEl.value = rowsMobileEl.value;
        if (zoomRangeMobile) {
          const s = Math.max(0, Math.min(100, parseInt(zoomRangeMobile.value, 10) || 0));
          const p = sliderToPercent(s);
          if (zoomRange) zoomRange.value = String(s);
          if (zoomNumber) zoomNumber.value = String(p);
          zoomToPercent(p);
        }
      }

      document.getElementById('year').textContent = new Date().getFullYear();

      document.querySelectorAll('[data-tool]').forEach(button => {
        button.addEventListener('click', () => {
          setTool(button.dataset.tool);
        });
      });

      document.querySelector('[data-action="text"]').addEventListener('click', () => {
        openTextDialog();
      });

      document.querySelector('[data-action="toggle-snap"]').addEventListener('click', (e) => {
        snapEnabled = !snapEnabled;
        e.target.classList.toggle('active', snapEnabled);
        showToast(snapEnabled ? 'å¸é™„å·²å¯ç”¨' : 'å¸é™„å·²ç¦ç”¨');
      });

      document.querySelector('[data-action="toggle-rulers"]').addEventListener('click', (e) => {
        rulersEnabled = !rulersEnabled;
        e.target.classList.toggle('active', rulersEnabled);
        document.querySelector('[data-action="toggle-rulers-mobile"]')?.classList.toggle('active', rulersEnabled);
        boardStage.classList.toggle('with-rulers', rulersEnabled);
        requestAnimationFrame(() => requestAnimationFrame(() => {
          resizeCanvas();
          drawRulers();
        }));
      });

      // removed origin toggle

      document.querySelectorAll('[data-action="undo"]').forEach(btn => btn.addEventListener('click', () => undo()));
      document.querySelectorAll('[data-action="redo"]').forEach(btn => btn.addEventListener('click', () => redo()));
      document.querySelector('[data-action="arrange"]').addEventListener('click', () => autoArrangeImages());
      document.querySelector('[data-action="export"]').addEventListener('click', () => exportCanvas());
      document.querySelector('[data-action="duplicate"]').addEventListener('click', () => duplicateObject());
      document.querySelector('[data-action="fullscreen"]').addEventListener('click', () => toggleFullscreen());
      document.querySelectorAll('[data-action="reset"]').forEach(btn => btn.addEventListener('click', () => resetCanvas()));
      document.querySelector('[data-action="fit-content"]').addEventListener('click', () => fitContentView());
      
      // Mobile menu toggle
      document.querySelector('[data-action="toggle-menu"]')?.addEventListener('click', () => {
        toggleMobileMenu();
        if (mobileMenu.classList.contains('show')) {
          syncMobileControls();
        }
      });
      
      // Mobile menu event listeners
      document.querySelector('[data-action="toggle-snap-mobile"]')?.addEventListener('click', (e) => {
        snapEnabled = !snapEnabled;
        e.target.classList.toggle('active', snapEnabled);
        document.querySelector('[data-action="toggle-snap"]')?.classList.toggle('active', snapEnabled);
        showToast(snapEnabled ? 'å¸é™„å·²å¯ç”¨' : 'å¸é™„å·²ç¦ç”¨');
      });
      document.querySelector('[data-action="toggle-rulers-mobile"]')?.addEventListener('click', (e) => {
        rulersEnabled = !rulersEnabled;
        e.target.classList.toggle('active', rulersEnabled);
        document.querySelector('[data-action="toggle-rulers"]')?.classList.toggle('active', rulersEnabled);
        boardStage.classList.toggle('with-rulers', rulersEnabled);
        requestAnimationFrame(() => requestAnimationFrame(() => {
          resizeCanvas();
          drawRulers();
        }));
      });
      
      document.querySelector('[data-action="undo-mobile"]')?.addEventListener('click', () => undo());
      document.querySelector('[data-action="redo-mobile"]')?.addEventListener('click', () => redo());
      document.querySelector('[data-action="arrange-mobile"]')?.addEventListener('click', () => {
        syncDesktopControls();
        autoArrangeImages();
      });
      document.querySelector('[data-action="export-mobile"]')?.addEventListener('click', () => exportCanvas());
      document.querySelector('[data-action="duplicate-mobile"]')?.addEventListener('click', () => duplicateObject());
      document.querySelector('[data-action="delete-mobile"]')?.addEventListener('click', () => deleteActiveObjects());
      document.querySelector('[data-action="fullscreen-mobile"]')?.addEventListener('click', () => toggleFullscreen());
      document.querySelector('[data-action="reset-mobile"]')?.addEventListener('click', () => resetCanvas());
      document.querySelector('[data-action="fit-content-mobile"]')?.addEventListener('click', () => fitContentView());
      
      // Sync mobile controls with desktop
      colorPickerMobile?.addEventListener('input', () => {
        colorPicker.value = colorPickerMobile.value;
        ensureBrushSettings();
        shapeOptions.stroke = colorPicker.value;
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          if (activeObject.type === 'textbox') {
            activeObject.set('fill', colorPicker.value);
            canvas.renderAll();
            saveHistory();
          } else if (activeObject.type === 'path' || activeObject.type === 'rect' || activeObject.type === 'ellipse') {
            activeObject.set('stroke', colorPicker.value);
            canvas.renderAll();
            saveHistory();
          }
        }
      });
      
      brushSizeMobile?.addEventListener('input', () => {
        brushSizeInput.value = brushSizeMobile.value;
        brushSizeNumber.value = brushSizeMobile.value;
        brushSizeNumberMobile.value = brushSizeMobile.value;
        ensureBrushSettings();
        shapeOptions.strokeWidth = parseInt(brushSizeMobile.value, 10) || 1;
      });

      zoomRangeMobile?.addEventListener('input', () => {
        const s = Math.max(0, Math.min(100, parseInt(zoomRangeMobile.value, 10) || 0));
        const p = sliderToPercent(s);
        zoomRangeMobile.value = s;
        zoomNumberMobile.value = p;
        zoomRange.value = s;
        zoomNumber.value = p;
        zoomToPercent(p);
      });

      zoomNumberMobile?.addEventListener('input', () => {
        const p = Math.max(10, Math.min(1000, parseInt(zoomNumberMobile.value, 10) || 100));
        const s = percentToSlider(p);
        zoomNumberMobile.value = p;
        zoomRangeMobile.value = s;
        zoomRange.value = s;
        zoomNumber.value = p;
        zoomToPercent(p);
      });

      brushSizeNumberMobile?.addEventListener('input', () => {
        const value = Math.max(1, Math.min(60, parseInt(brushSizeNumberMobile.value, 10) || 8));
        brushSizeNumberMobile.value = value;
        brushSizeMobile.value = value;
        brushSizeInput.value = value;
        brushSizeNumber.value = value;
        ensureBrushSettings();
      });
      
      // èƒŒæ™¯ï¼ˆç§»åŠ¨ç«¯ï¼‰
      bgModeMobile?.addEventListener('change', () => {
        if (bgMode) bgMode.value = bgModeMobile.value;
        if (bgModeMobile.value === 'transparent') {
          canvas.setBackgroundColor(null, canvas.renderAll.bind(canvas));
        } else {
          const color = (bgColorMobile?.value || bgColor?.value || '#ffffff');
          if (bgColor) bgColor.value = color;
          canvas.setBackgroundColor(color, canvas.renderAll.bind(canvas));
        }
      });
      bgColorMobile?.addEventListener('input', () => {
        const color = bgColorMobile.value || '#ffffff';
        if (bgColor) bgColor.value = color;
        if ((bgModeMobile && bgModeMobile.value === 'solid') || (bgMode && bgMode.value === 'solid')) {
          canvas.setBackgroundColor(color, canvas.renderAll.bind(canvas));
        }
      });
      
      imageInputMobile?.addEventListener('change', (event) => {
        handleFiles(event.target.files);
        imageInputMobile.value = '';
        mobileMenu.classList.remove('show');
      });

      heroFocusBtn?.addEventListener('click', () => {
        boardShell.scrollIntoView({ behavior: 'smooth', block: 'center' });
      });

      heroFullscreenBtn?.addEventListener('click', () => toggleFullscreen());

      document.querySelector('[data-action="cancel-text"]').addEventListener('click', () => closeTextDialog());
      document.querySelector('[data-action="confirm-text"]').addEventListener('click', () => addTextToCanvas());

      textPanel.addEventListener('click', (event) => {
        if (event.target === textPanel) {
          closeTextDialog();
        }
      });

      document.querySelectorAll('.export-size-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const multiplier = parseFloat(btn.dataset.multiplier);
          performExport(multiplier);
        });
      });

      document.querySelector('[data-action="cancel-export"]').addEventListener('click', () => closeExportDialog());

      document.querySelector('[data-action="confirm-export-size"]').addEventListener('click', () => {
        const wEl = document.getElementById('exportWidth');
        const hEl = document.getElementById('exportHeight');
        performExportWithSize(Number(wEl.value || 0), Number(hEl.value || 0));
      });

      exportPanel.addEventListener('click', (event) => {
        if (event.target === exportPanel) {
          closeExportDialog();
        }
      });

      imageInput.addEventListener('change', (event) => {
        handleFiles(event.target.files);
        imageInput.value = '';
      });

      colorPicker.addEventListener('input', () => {
        ensureBrushSettings();
        const activeObject = canvas.getActiveObject();
        if (activeObject) {
          if (activeObject.type === 'textbox') {
            activeObject.set('fill', colorPicker.value);
            canvas.renderAll();
            saveHistory();
          } else if (activeObject.type === 'path' || activeObject.type === 'rect' || activeObject.type === 'ellipse') {
            activeObject.set('stroke', colorPicker.value);
            canvas.renderAll();
            saveHistory();
          }
        }
        shapeOptions.stroke = colorPicker.value;
      });

      brushSizeInput.addEventListener('input', () => {
        brushSizeNumber.value = brushSizeInput.value;
        ensureBrushSettings();
        const activeObject = canvas.getActiveObject();
        if (activeObject && (activeObject.type === 'rect' || activeObject.type === 'ellipse')) {
          activeObject.set('strokeWidth', parseInt(brushSizeInput.value, 10) || 1);
          canvas.renderAll();
          saveHistory();
        }
        shapeOptions.strokeWidth = parseInt(brushSizeInput.value, 10) || 1;
      });

      brushSizeNumber.addEventListener('input', () => {
        const value = Math.max(1, Math.min(60, parseInt(brushSizeNumber.value, 10) || 8));
        brushSizeNumber.value = value;
        brushSizeInput.value = value;
        ensureBrushSettings();
        const activeObject = canvas.getActiveObject();
        if (activeObject && (activeObject.type === 'rect' || activeObject.type === 'ellipse')) {
          activeObject.set('strokeWidth', value);
          canvas.renderAll();
          saveHistory();
        }
        shapeOptions.strokeWidth = value;
      });

      zoomRange?.addEventListener('input', () => {
        const s = Math.max(0, Math.min(100, parseInt(zoomRange.value, 10) || 0));
        const p = sliderToPercent(s);
        zoomRange.value = s;
        zoomNumber.value = p;
        zoomToPercent(p);
      });

      zoomNumber?.addEventListener('input', () => {
        const p = Math.max(10, Math.min(1000, parseInt(zoomNumber.value, 10) || 100));
        const s = percentToSlider(p);
        zoomNumber.value = p;
        zoomRange.value = s;
        zoomToPercent(p);
      });

      boardStage.addEventListener('dragover', (event) => {
        event.preventDefault();
        boardStage.classList.add('dragover');
      });

      boardStage.addEventListener('dragleave', () => {
        boardStage.classList.remove('dragover');
      });

      boardStage.addEventListener('drop', (event) => {
        event.preventDefault();
        boardStage.classList.remove('dragover');
        handleFiles(event.dataTransfer.files);
      });

      document.addEventListener('keydown', (event) => {
        const isInputing = event.target && (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.isContentEditable);
        if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'z') {
          event.preventDefault();
          if (event.shiftKey) {
            redo();
          } else {
            undo();
          }
        }
        if ((event.metaKey || event.ctrlKey) && (event.key.toLowerCase() === 'y')) {
          event.preventDefault();
          redo();
        }
        if ((event.metaKey || event.ctrlKey) && event.key.toLowerCase() === 'd') {
          event.preventDefault();
          duplicateObject();
        }
        if (!isInputing && (event.key === 'Delete' || event.key === 'Backspace')) {
          const activeObjects = canvas.getActiveObjects();
          if (activeObjects.length) {
            event.preventDefault();
            activeObjects.forEach(obj => canvas.remove(obj));
            canvas.discardActiveObject();
            canvas.renderAll();
            saveHistory();
            showToast('å·²åˆ é™¤é€‰ä¸­å¯¹è±¡');
          }
        }
        if (event.key === 'Escape' && !textPanel.hidden) {
          closeTextDialog();
        }
        if (event.key === 'Escape' && mobileMenu?.classList.contains('show')) {
          mobileMenu.classList.remove('show');
        }
        if (event.key === 'Escape' && shapeState.active) {
          if (shapeState.preview) {
            canvas.remove(shapeState.preview);
            shapeState.preview = null;
          }
          shapeState.active = false;
          shapeState.kind = null;
          canvas.requestRenderAll();
          showToast('å·²å–æ¶ˆç»˜åˆ¶');
        }

        // å·¥å…·å¿«æ·é”®ï¼ˆä»…åœ¨éè¾“å…¥çŠ¶æ€ä¸”æ— ä¿®é¥°é”®æ—¶ç”Ÿæ•ˆï¼‰
        if (!isInputing && !event.ctrlKey && !event.metaKey && !event.altKey) {
          const k = event.key;
          if (!k) return;
          const lower = k.toLowerCase();
          if (lower === 'v') { setTool('pointer'); }
          else if (lower === 'b') { setTool('brush'); }
          else if (lower === 'e') { setTool('eraser'); }
          else if (lower === 'h') { setTool('pan'); }
          else if (lower === 'r') { setTool('rect'); }
          else if (lower === 'o') { setTool('ellipse'); }
          else if (lower === 't') { openTextDialog(); }
          else if (lower === 'f') { toggleFullscreen(); }
          else if (k === ' ' || lower === ' ') { event.preventDefault(); setTool('pan'); }
        }
      });



      // æ‹–åŠ¨åŠŸèƒ½çŠ¶æ€
      let isDragging = false;
      let dragStart = { x: 0, y: 0 };
      let panMode = false;

      // Pinch-zoom state
      let isPinching = false;
      let pinchStartDist = 0;
      let pinchStartZoom = 1;
      let pinchCenter = null;
      let savedDrawingMode = false;
      let savedSkipTargetFind = false;
      let savedSelection = true;

      function getClientPoint(evt) {
        if (evt && evt.touches && evt.touches.length) {
          return { x: evt.touches[0].clientX, y: evt.touches[0].clientY };
        }
        if (evt && evt.changedTouches && evt.changedTouches.length) {
          return { x: evt.changedTouches[0].clientX, y: evt.changedTouches[0].clientY };
        }
        return { x: evt?.clientX ?? 0, y: evt?.clientY ?? 0 };
      }

      // Pinch-zoom helpers
      function getTouchPair(evt) {
        const t = evt && evt.touches;
        const c = evt && evt.changedTouches;
        if (t && t.length >= 2) return [t[0], t[1]];
        if (c && c.length >= 2) return [c[0], c[1]];
        return null;
      }
      function touchDistance(a, b) {
        const dx = a.clientX - b.clientX;
        const dy = a.clientY - b.clientY;
        return Math.hypot(dx, dy) || 0;
      }
      function touchMidpoint(a, b) {
        return { x: (a.clientX + b.clientX) / 2, y: (a.clientY + b.clientY) / 2 };
      }
      function clientToCanvasPoint(c) {
        const rect = canvas.upperCanvasEl.getBoundingClientRect();
        return new fabric.Point(c.x - rect.left, c.y - rect.top);
      }

      // Early DOM interception to avoid Fabric selection during pinch
      const upperEl = canvas.upperCanvasEl;
      upperEl.addEventListener('touchstart', (e) => {
        if (e.touches && e.touches.length === 2) {
          e.preventDefault();
          e.stopImmediatePropagation();
          isPinching = true;
          pinchStartDist = touchDistance(e.touches[0], e.touches[1]);
          pinchStartZoom = canvas.getZoom() || 1;
          const mid = touchMidpoint(e.touches[0], e.touches[1]);
          pinchCenter = clientToCanvasPoint(mid);
          savedDrawingMode = canvas.isDrawingMode;
          savedSkipTargetFind = canvas.skipTargetFind;
          savedSelection = canvas.selection;
          canvas.isDrawingMode = false;
          canvas.skipTargetFind = true;
          canvas.selection = false;
          canvas.discardActiveObject();
          canvas.defaultCursor = 'grabbing';
          canvas.requestRenderAll();
        }
      }, { passive: false, capture: true });

      upperEl.addEventListener('touchmove', (e) => {
        if (!isPinching || !(e.touches && e.touches.length === 2)) return;
        e.preventDefault();
        e.stopImmediatePropagation();
        const d = touchDistance(e.touches[0], e.touches[1]);
        const ratio = d / (pinchStartDist || 1);
        const z = clampZoom((pinchStartZoom || 1) * (isFinite(ratio) ? ratio : 1));
        const mid = touchMidpoint(e.touches[0], e.touches[1]);
        pinchCenter = clientToCanvasPoint(mid);
        canvas.zoomToPoint(pinchCenter, z);
        canvas.requestRenderAll();
        updateZoomInputs();
      }, { passive: false, capture: true });

      function endPinch() {
        isPinching = false;
        canvas.skipTargetFind = savedSkipTargetFind;
        canvas.selection = savedSelection;
        canvas.isDrawingMode = savedDrawingMode;
        canvas.defaultCursor = panMode ? 'grab' : 'default';
        canvas.requestRenderAll();
      }

      upperEl.addEventListener('touchend', (e) => {
        if (isPinching && (!e.touches || e.touches.length < 2)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          endPinch();
        }
      }, { passive: false, capture: true });

      upperEl.addEventListener('touchcancel', (e) => {
        if (isPinching) {
          e.preventDefault();
          e.stopImmediatePropagation();
          endPinch();
        }
      }, { passive: false, capture: true });

      canvas.on('mouse:wheel', (opt) => {
        const e = opt.e;
        e.preventDefault();
        e.stopPropagation();
        const delta = e.deltaY;
        const factor = Math.pow(0.999, delta);
        let zoom = clampZoom((canvas.getZoom() || 1) * factor);
        const p = new fabric.Point(e.offsetX, e.offsetY);
        canvas.zoomToPoint(p, zoom);
        canvas.requestRenderAll();
        updateZoomInputs();
      });

      // ç”»å¸ƒæ‹–åŠ¨/ç¼©æ”¾ï¼ˆæ”¯æŒé¼ æ ‡ä¸è§¦æ‘¸ï¼‰
      canvas.on('mouse:down', (opt) => {
        const e = opt.e;
        if (isPinching) { e?.preventDefault?.(); return; }
        const pair = getTouchPair(e);
        if (pair) {
          e?.preventDefault?.();
          isPinching = true;
          pinchStartDist = touchDistance(pair[0], pair[1]);
          pinchStartZoom = canvas.getZoom() || 1;
          const mid = touchMidpoint(pair[0], pair[1]);
          pinchCenter = clientToCanvasPoint(mid);
          canvas.selection = false;
          canvas.defaultCursor = 'grabbing';
          canvas.renderAll();
          return;
        }
        // Shape drawing start
        if (currentTool === 'rect' || currentTool === 'ellipse') {
          const p0 = canvas.getPointer(e);
          shapeState.active = true;
          shapeState.kind = currentTool;
          shapeState.start = { x: p0.x, y: p0.y };
          if (shapeState.preview) {
            canvas.remove(shapeState.preview);
            shapeState.preview = null;
          }
          if (currentTool === 'rect') {
            shapeState.preview = new fabric.Rect({
              left: p0.x,
              top: p0.y,
              originX: 'center',
              originY: 'center',
              width: 1,
              height: 1,
              stroke: shapeOptions.stroke,
              strokeWidth: shapeOptions.strokeWidth,
              fill: shapeOptions.fillEnabled ? shapeOptions.fill : null,
              strokeDashArray: shapeOptions.strokeDashArray || null,
              selectable: false,
              evented: false,
              excludeFromExport: true,
              opacity: 0.85
            });
          } else {
            shapeState.preview = new fabric.Ellipse({
              left: p0.x,
              top: p0.y,
              originX: 'center',
              originY: 'center',
              rx: 0.5,
              ry: 0.5,
              stroke: shapeOptions.stroke,
              strokeWidth: shapeOptions.strokeWidth,
              fill: shapeOptions.fillEnabled ? shapeOptions.fill : null,
              strokeDashArray: shapeOptions.strokeDashArray || null,
              selectable: false,
              evented: false,
              excludeFromExport: true,
              opacity: 0.85
            });
          }
          canvas.add(shapeState.preview);
          canvas.requestRenderAll();
          return;
        }
        const isMiddleButton = e && e.button === 1;
        const allowPan = isMiddleButton || panMode;
        if (allowPan) {
          e?.preventDefault?.();
          isDragging = true;
          const p = getClientPoint(e);
          dragStart = { x: p.x, y: p.y };
          canvas.selection = false;
          canvas.defaultCursor = 'grabbing';
          canvas.renderAll();
        }
      });

      canvas.on('mouse:move', (opt) => {
        const e = opt.e;
        if (isPinching) {
          const pair = getTouchPair(e);
          if (pair) {
            e?.preventDefault?.();
            const d = touchDistance(pair[0], pair[1]);
            const ratio = d / (pinchStartDist || 1);
            const z = clampZoom((pinchStartZoom || 1) * (isFinite(ratio) ? ratio : 1));
            const mid = touchMidpoint(pair[0], pair[1]);
            pinchCenter = clientToCanvasPoint(mid);
            canvas.zoomToPoint(pinchCenter, z);
            canvas.requestRenderAll();
            updateZoomInputs();
            return;
          }
        }
        if (shapeState.active && shapeState.preview) {
          const p1 = canvas.getPointer(e);
          const x0 = shapeState.start.x, y0 = shapeState.start.y;
          let w = Math.abs(p1.x - x0);
          let h = Math.abs(p1.y - y0);
          if (e && e.shiftKey) {
            const s = Math.min(w, h);
            w = s; h = s;
          }
          const cx = (x0 + p1.x) / 2;
          const cy = (y0 + p1.y) / 2;
          if (shapeState.kind === 'rect') {
            shapeState.preview.set({ left: cx, top: cy, width: Math.max(0.5, w), height: Math.max(0.5, h) });
          } else if (shapeState.kind === 'ellipse') {
            shapeState.preview.set({ left: cx, top: cy, rx: Math.max(0.25, w / 2), ry: Math.max(0.25, h / 2) });
          }
          if (snapEnabled) {
            calculateSnap(shapeState.preview);
          }
          canvas.requestRenderAll();
          return;
        }
        if (!isDragging) return;
        const p = getClientPoint(e);
        const dx = p.x - dragStart.x;
        const dy = p.y - dragStart.y;

        const vpt = canvas.viewportTransform;
        vpt[4] += dx;
        vpt[5] += dy;

        dragStart = { x: p.x, y: p.y };
        canvas.requestRenderAll();
      });

      canvas.on('mouse:up', (opt) => {
        if (isPinching) {
          isPinching = false;
        }
        if (shapeState.active) {
          const obj = shapeState.preview;
          shapeState.active = false;
          shapeState.kind = null;
          if (obj) {
            const zoom = canvas.getZoom() || 1;
            const minDim = 3 / zoom;
            const w = obj.getScaledWidth?.() || obj.width || 0;
            const h = obj.getScaledHeight?.() || obj.height || 0;
            if (Math.max(w, h) < minDim) {
              canvas.remove(obj);
              shapeState.preview = null;
              canvas.requestRenderAll();
            } else {
              obj.set({ selectable: true, evented: true, excludeFromExport: false, opacity: 1 });
              shapeState.preview = null;
              canvas.setActiveObject(obj);
              obj.setCoords();
              canvas.requestRenderAll();
              saveHistory();
            }
          }
        }
        if (isDragging) {
          isDragging = false;
          canvas.selection = true;
          canvas.defaultCursor = panMode ? 'grab' : 'default';
          canvas.renderAll();
        }
      });

      // è§¦æ‘¸äº‹ä»¶é€šè¿‡ mouse:* ç»Ÿä¸€å¤„ç†ï¼Œæ— éœ€é¢å¤– touch:* äº‹ä»¶ä¸ DOM ç›‘å¬
      
      // Close mobile menu when clicking/tapping outside, including canvas area
      function closeMenuIfOutside(target) {
        if (!mobileMenu?.classList.contains('show')) return;
        const isMenuClick = mobileMenu.contains(target);
        const isToggleClick = target.closest && target.closest('[data-action="toggle-menu"]');
        if (!isMenuClick && !isToggleClick) {
          mobileMenu.classList.remove('show');
        }
      }
      // Fallback for mouse click
      document.addEventListener('click', (event) => closeMenuIfOutside(event.target));
      // Capture pointer/touch early so Fabric/gesture handling wonâ€™t block closing
      document.addEventListener('pointerdown', (event) => closeMenuIfOutside(event.target), { capture: true });
      document.addEventListener('touchstart', (event) => closeMenuIfOutside(event.target), { capture: true });

      canvas.on('selection:created', synchronizeColorWithSelection);
      canvas.on('selection:updated', synchronizeColorWithSelection);
      canvas.on('selection:cleared', () => ensureBrushSettings());

      canvas.on('object:moving', (e) => {
        calculateSnap(e.target);
      });

      canvas.on('path:created', () => {
        if (currentBrushMode === 'erase') {
          setTool('eraser');
        }
        saveHistory();
      });
      canvas.on('object:modified', saveHistory);
      canvas.on('object:removed', saveHistory);
      canvas.on('object:added', function (e) {
        if (panMode && e.target) {
          e.target.selectable = false;
          e.target.evented = false;
        }
        if (!history.undoStack.length) {
          saveHistory();
        }
      });

      // Rulers/HUD updates
      canvas.on('after:render', () => { drawRulers(); });

      document.addEventListener('fullscreenchange', () => {
        const fullscreenButton = document.querySelector('[data-action="fullscreen"]');
        const isFull = Boolean(document.fullscreenElement);
        boardShell.classList.toggle('is-fullscreen', isFull);
        if (fullscreenButton) {
          fullscreenButton.innerHTML = isFull ? `<span class="btn-icon">âœ•</span><span class="btn-text">é€€å‡ºå…¨å±</span>` : `<span class="btn-icon">â›¶</span><span class="btn-text">å…¨å±ä¸“æ³¨</span>`;
        }
        requestAnimationFrame(updateBoardStageHeight);
      });

      // Initial overlay sizing
      if (typeof resizeOverlays === 'function') resizeOverlays();

      setTool('pointer');
      saveHistory();
      updateHistoryButtons();
      updateZoomInputs();

      // Shape controls wiring
      const fillEnabledEl = document.getElementById('fillEnabled');
      const fillColorEl = document.getElementById('fillColor');
      const dashPatternEl = document.getElementById('dashPattern');
      if (fillEnabledEl && fillColorEl && dashPatternEl) {
        fillEnabledEl.addEventListener('change', () => {
          shapeOptions.fillEnabled = !!fillEnabledEl.checked;
          const active = canvas.getActiveObject();
          if (active && (active.type === 'rect' || active.type === 'ellipse')) {
            active.set('fill', shapeOptions.fillEnabled ? (shapeOptions.fill || fillColorEl.value) : null);
            canvas.requestRenderAll();
            saveHistory();
          }
        });
        fillColorEl.addEventListener('input', () => {
          shapeOptions.fill = fillColorEl.value;
          const active = canvas.getActiveObject();
          if (active && (active.type === 'rect' || active.type === 'ellipse')) {
            if (shapeOptions.fillEnabled) {
              active.set('fill', fillColorEl.value);
              canvas.requestRenderAll();
              saveHistory();
            }
          }
        });
        function parseDash(v) {
          if (!v) return null;
          const arr = String(v).split(',').map(s => Math.max(0, parseFloat(s.trim()))).filter(n => isFinite(n) && n > 0);
          return arr.length ? arr : null;
        }
        dashPatternEl.addEventListener('input', () => {
          shapeOptions.strokeDashArray = parseDash(dashPatternEl.value);
          const active = canvas.getActiveObject();
          if (active && (active.type === 'rect' || active.type === 'ellipse')) {
            active.set('strokeDashArray', shapeOptions.strokeDashArray || null);
            canvas.requestRenderAll();
            saveHistory();
          }
        });
      }
    })();
  </script>
</body>
</html>
